{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue';\nimport useHistory from '../../composables/private/use-history.js';\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js';\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js';\nimport useTimeout from '../../composables/private/use-timeout.js';\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js';\nimport TouchPan from '../../directives/TouchPan.js';\nimport { createComponent } from '../../utils/private/create.js';\nimport { between } from '../../utils/format.js';\nimport { hSlot, hDir } from '../../utils/private/render.js';\nimport { layoutKey, emptyRenderFn } from '../../utils/private/symbols.js';\nconst duration = 150;\nexport default createComponent({\n  name: 'QDrawer',\n  inheritAttrs: false,\n  props: {\n    ...useModelToggleProps,\n    ...useDarkProps,\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => ['left', 'right'].includes(v)\n    },\n    width: {\n      type: Number,\n      default: 300\n    },\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n    noMiniAnimation: Boolean,\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n    behavior: {\n      type: String,\n      validator: v => ['default', 'desktop', 'mobile'].includes(v),\n      default: 'default'\n    },\n    bordered: Boolean,\n    elevated: Boolean,\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n  emits: [...useModelToggleEmits, 'onLayout', 'miniState'],\n  setup(props, {\n    slots,\n    emit,\n    attrs\n  }) {\n    const vm = getCurrentInstance();\n    const {\n      proxy: {\n        $q\n      }\n    } = vm;\n    const isDark = useDark(props, $q);\n    const {\n      preventBodyScroll\n    } = usePreventScroll();\n    const {\n      registerTimeout,\n      removeTimeout\n    } = useTimeout();\n    const $layout = inject(layoutKey, emptyRenderFn);\n    if ($layout === emptyRenderFn) {\n      console.error('QDrawer needs to be child of QLayout');\n      return emptyRenderFn;\n    }\n    let lastDesktopState,\n      timerMini = null,\n      layoutTotalWidthWatcher;\n    const belowBreakpoint = ref(props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    const isMini = computed(() => props.mini === true && belowBreakpoint.value !== true);\n    const size = computed(() => isMini.value === true ? props.miniWidth : props.width);\n    const showing = ref(props.showIfAbove === true && belowBreakpoint.value === false ? true : props.modelValue === true);\n    const hideOnRouteChange = computed(() => props.persistent !== true && (belowBreakpoint.value === true || onScreenOverlay.value === true));\n    function handleShow(evt, noEvent) {\n      addToHistory();\n      evt !== false && $layout.animate();\n      applyPosition(0);\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[otherSide.value];\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false);\n        }\n        applyBackdrop(1);\n        $layout.isContainer.value !== true && preventBodyScroll(true);\n      } else {\n        applyBackdrop(0);\n        evt !== false && setScrollable(false);\n      }\n      registerTimeout(() => {\n        evt !== false && setScrollable(true);\n        noEvent !== true && emit('show', evt);\n      }, duration);\n    }\n    function handleHide(evt, noEvent) {\n      removeFromHistory();\n      evt !== false && $layout.animate();\n      applyBackdrop(0);\n      applyPosition(stateDirection.value * size.value);\n      cleanup();\n      if (noEvent !== true) {\n        registerTimeout(() => {\n          emit('hide', evt);\n        }, duration);\n      } else {\n        removeTimeout();\n      }\n    }\n    const {\n      show,\n      hide\n    } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    });\n    const {\n      addToHistory,\n      removeFromHistory\n    } = useHistory(showing, hide, hideOnRouteChange);\n    const instance = {\n      belowBreakpoint,\n      hide\n    };\n    const rightSide = computed(() => props.side === 'right');\n    const stateDirection = computed(() => ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1));\n    const flagBackdropBg = ref(0);\n    const flagPanning = ref(false);\n    const flagMiniAnimate = ref(false);\n    const flagContentPosition = ref(\n    // starting with \"hidden\" for SSR\n    size.value * stateDirection.value);\n    const otherSide = computed(() => rightSide.value === true ? 'left' : 'right');\n    const offset = computed(() => showing.value === true && belowBreakpoint.value === false && props.overlay === false ? props.miniToOverlay === true ? props.miniWidth : size.value : 0);\n    const fixed = computed(() => props.overlay === true || props.miniToOverlay === true || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1 || $q.platform.is.ios === true && $layout.isContainer.value === true);\n    const onLayout = computed(() => props.overlay === false && showing.value === true && belowBreakpoint.value === false);\n    const onScreenOverlay = computed(() => props.overlay === true && showing.value === true && belowBreakpoint.value === false);\n    const backdropClass = computed(() => 'fullscreen q-drawer__backdrop' + (showing.value === false && flagPanning.value === false ? ' hidden' : ''));\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${flagBackdropBg.value * 0.4})`\n    }));\n    const headerSlot = computed(() => rightSide.value === true ? $layout.rows.value.top[2] === 'r' : $layout.rows.value.top[0] === 'l');\n    const footerSlot = computed(() => rightSide.value === true ? $layout.rows.value.bottom[2] === 'r' : $layout.rows.value.bottom[0] === 'l');\n    const aboveStyle = computed(() => {\n      const css = {};\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${$layout.header.offset}px`;\n        } else if ($layout.header.space === true) {\n          css.top = `${$layout.header.size}px`;\n        }\n      }\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${$layout.footer.offset}px`;\n        } else if ($layout.footer.space === true) {\n          css.bottom = `${$layout.footer.size}px`;\n        }\n      }\n      return css;\n    });\n    const style = computed(() => {\n      const style = {\n        width: `${size.value}px`,\n        transform: `translateX(${flagContentPosition.value}px)`\n      };\n      return belowBreakpoint.value === true ? style : Object.assign(style, aboveStyle.value);\n    });\n    const contentClass = computed(() => 'q-drawer__content fit ' + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto'));\n    const classes = computed(() => `q-drawer q-drawer--${props.side}` + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '') + (props.bordered === true ? ' q-drawer--bordered' : '') + (isDark.value === true ? ' q-drawer--dark q-dark' : '') + (flagPanning.value === true ? ' no-transition' : showing.value === true ? '' : ' q-layout--prevent-focus') + (belowBreakpoint.value === true ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding' : ` q-drawer--${isMini.value === true ? 'mini' : 'standard'}` + (fixed.value === true || onLayout.value !== true ? ' fixed' : '') + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '') + (headerSlot.value === true ? ' q-drawer--top-padding' : '')));\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value;\n      return [[TouchPan, onOpenPan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true\n      }]];\n    });\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side;\n      return [[TouchPan, onClosePan, void 0, {\n        [dir]: true,\n        mouse: true,\n        mouseAllDir: true\n      }]];\n    });\n    function updateBelowBreakpoint() {\n      updateLocal(belowBreakpoint, props.behavior === 'mobile' || props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint);\n    }\n    watch(belowBreakpoint, val => {\n      if (val === true) {\n        // from lg to xs\n        lastDesktopState = showing.value;\n        showing.value === true && hide(false);\n      } else if (props.overlay === false && props.behavior !== 'mobile' && lastDesktopState !== false) {\n        // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0);\n          applyBackdrop(0);\n          cleanup();\n        } else {\n          show(false);\n        }\n      }\n    });\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[oldSide] === instance) {\n        $layout.instances[oldSide] = void 0;\n        $layout[oldSide].space = false;\n        $layout[oldSide].offset = 0;\n      }\n      $layout.instances[newSide] = instance;\n      $layout[newSide].size = size.value;\n      $layout[newSide].space = onLayout.value;\n      $layout[newSide].offset = offset.value;\n    });\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint();\n      }\n    });\n    watch(() => props.behavior + props.breakpoint, updateBelowBreakpoint);\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true);\n      val === true && updateBelowBreakpoint();\n    });\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0);\n    });\n    watch(offset, val => {\n      updateLayout('offset', val);\n    });\n    watch(onLayout, val => {\n      emit('onLayout', val);\n      updateLayout('space', val);\n    });\n    watch(rightSide, () => {\n      applyPosition();\n    });\n    watch(size, val => {\n      applyPosition();\n      updateSizeOnLayout(props.miniToOverlay, val);\n    });\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value);\n    });\n    watch(() => $q.lang.rtl, () => {\n      applyPosition();\n    });\n    watch(() => props.mini, () => {\n      if (props.noMiniAnimation) return;\n      if (props.modelValue === true) {\n        animateMini();\n        $layout.animate();\n      }\n    });\n    watch(isMini, val => {\n      emit('miniState', val);\n    });\n    function applyPosition(position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value;\n          applyPosition(stateDirection.value * position);\n        });\n      } else {\n        if ($layout.isContainer.value === true && rightSide.value === true && (belowBreakpoint.value === true || Math.abs(position) === size.value)) {\n          position += stateDirection.value * $layout.scrollbarWidth.value;\n        }\n        flagContentPosition.value = position;\n      }\n    }\n    function applyBackdrop(x) {\n      flagBackdropBg.value = x;\n    }\n    function setScrollable(v) {\n      const action = v === true ? 'remove' : $layout.isContainer.value !== true ? 'add' : '';\n      action !== '' && document.body.classList[action]('q-body--drawer-toggle');\n    }\n    function animateMini() {\n      timerMini !== null && clearTimeout(timerMini);\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate');\n      }\n      flagMiniAnimate.value = true;\n      timerMini = setTimeout(() => {\n        timerMini = null;\n        flagMiniAnimate.value = false;\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate');\n        }\n      }, 150);\n    }\n    function onOpenPan(evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return;\n      }\n      const width = size.value,\n        position = between(evt.distance.x, 0, width);\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width);\n        if (opened === true) {\n          show();\n        } else {\n          $layout.animate();\n          applyBackdrop(0);\n          applyPosition(stateDirection.value * width);\n        }\n        flagPanning.value = false;\n        return;\n      }\n      applyPosition(($q.lang.rtl === true ? rightSide.value !== true : rightSide.value) ? Math.max(width - position, 0) : Math.min(0, position - width));\n      applyBackdrop(between(position / width, 0, 1));\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n    function onClosePan(evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return;\n      }\n      const width = size.value,\n        dir = evt.direction === props.side,\n        position = ($q.lang.rtl === true ? dir !== true : dir) ? between(evt.distance.x, 0, width) : 0;\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width);\n        if (opened === true) {\n          $layout.animate();\n          applyBackdrop(1);\n          applyPosition(0);\n        } else {\n          hide();\n        }\n        flagPanning.value = false;\n        return;\n      }\n      applyPosition(stateDirection.value * position);\n      applyBackdrop(between(1 - position / width, 0, 1));\n      if (evt.isFirst === true) {\n        flagPanning.value = true;\n      }\n    }\n    function cleanup() {\n      preventBodyScroll(false);\n      setScrollable(true);\n    }\n    function updateLayout(prop, val) {\n      $layout.update(props.side, prop, val);\n    }\n    function updateLocal(prop, val) {\n      if (prop.value !== val) {\n        prop.value = val;\n      }\n    }\n    function updateSizeOnLayout(miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size);\n    }\n    $layout.instances[props.side] = instance;\n    updateSizeOnLayout(props.miniToOverlay, size.value);\n    updateLayout('space', onLayout.value);\n    updateLayout('offset', offset.value);\n    if (props.showIfAbove === true && props.modelValue !== true && showing.value === true && props['onUpdate:modelValue'] !== void 0) {\n      emit('update:modelValue', true);\n    }\n    onMounted(() => {\n      emit('onLayout', onLayout.value);\n      emit('miniState', isMini.value);\n      lastDesktopState = props.showIfAbove === true;\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide;\n        action(false, true);\n      };\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn);\n        return;\n      }\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher();\n        layoutTotalWidthWatcher = void 0;\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false);\n        } else {\n          fn();\n        }\n      });\n    });\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher();\n      if (timerMini !== null) {\n        clearTimeout(timerMini);\n        timerMini = null;\n      }\n      showing.value === true && cleanup();\n      if ($layout.instances[props.side] === instance) {\n        $layout.instances[props.side] = void 0;\n        updateLayout('size', 0);\n        updateLayout('offset', 0);\n        updateLayout('space', false);\n      }\n    });\n    return () => {\n      const child = [];\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(withDirectives(h('div', {\n          key: 'open',\n          class: `q-drawer__opener fixed-${props.side}`,\n          'aria-hidden': 'true'\n        }), openDirective.value));\n        child.push(hDir('div', {\n          ref: 'backdrop',\n          class: backdropClass.value,\n          style: backdropStyle.value,\n          'aria-hidden': 'true',\n          onClick: hide\n        }, void 0, 'backdrop', props.noSwipeBackdrop !== true && showing.value === true, () => backdropCloseDirective.value));\n      }\n      const mini = isMini.value === true && slots.mini !== void 0;\n      const content = [h('div', {\n        ...attrs,\n        key: '' + mini,\n        // required otherwise Vue will not diff correctly\n        class: [contentClass.value, attrs.class]\n      }, mini === true ? slots.mini() : hSlot(slots.default))];\n      if (props.elevated === true && showing.value === true) {\n        content.push(h('div', {\n          class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n        }));\n      }\n      child.push(hDir('aside', {\n        ref: 'content',\n        class: classes.value,\n        style: style.value\n      }, content, 'contentclose', props.noSwipeClose !== true && belowBreakpoint.value === true, () => contentCloseDirective.value));\n      return h('div', {\n        class: 'q-drawer-container'\n      }, child);\n    };\n  }\n});","map":{"version":3,"names":["h","withDirectives","ref","computed","watch","onMounted","onBeforeUnmount","nextTick","inject","getCurrentInstance","useHistory","useModelToggle","useModelToggleProps","useModelToggleEmits","usePreventScroll","useTimeout","useDark","useDarkProps","TouchPan","createComponent","between","hSlot","hDir","layoutKey","emptyRenderFn","duration","name","inheritAttrs","props","side","type","String","default","validator","v","includes","width","Number","mini","Boolean","miniToOverlay","miniWidth","noMiniAnimation","breakpoint","showIfAbove","behavior","bordered","elevated","overlay","persistent","noSwipeOpen","noSwipeClose","noSwipeBackdrop","emits","setup","slots","emit","attrs","vm","proxy","$q","isDark","preventBodyScroll","registerTimeout","removeTimeout","$layout","console","error","lastDesktopState","timerMini","layoutTotalWidthWatcher","belowBreakpoint","totalWidth","value","isMini","size","showing","modelValue","hideOnRouteChange","onScreenOverlay","handleShow","evt","noEvent","addToHistory","animate","applyPosition","otherInstance","instances","otherSide","hide","applyBackdrop","isContainer","setScrollable","handleHide","removeFromHistory","stateDirection","cleanup","show","instance","rightSide","lang","rtl","flagBackdropBg","flagPanning","flagMiniAnimate","flagContentPosition","offset","fixed","view","indexOf","platform","is","ios","onLayout","backdropClass","backdropStyle","backgroundColor","headerSlot","rows","top","footerSlot","bottom","aboveStyle","css","header","space","footer","style","transform","Object","assign","contentClass","classes","openDirective","dir","onOpenPan","mouse","contentCloseDirective","onClosePan","backdropCloseDirective","mouseAllDir","updateBelowBreakpoint","updateLocal","val","newSide","oldSide","document","qScrollPrevented","scrollbarWidth","updateLayout","updateSizeOnLayout","animateMini","position","Math","abs","x","action","body","classList","clearTimeout","$el","add","setTimeout","remove","distance","isFinal","opened","min","max","isFirst","direction","prop","update","fn","child","push","key","class","onClick","content"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/components/drawer/QDrawer.js"],"sourcesContent":["import { h, withDirectives, ref, computed, watch, onMounted, onBeforeUnmount, nextTick, inject, getCurrentInstance } from 'vue'\n\nimport useHistory from '../../composables/private/use-history.js'\nimport useModelToggle, { useModelToggleProps, useModelToggleEmits } from '../../composables/private/use-model-toggle.js'\nimport usePreventScroll from '../../composables/private/use-prevent-scroll.js'\nimport useTimeout from '../../composables/private/use-timeout.js'\nimport useDark, { useDarkProps } from '../../composables/private/use-dark.js'\n\nimport TouchPan from '../../directives/TouchPan.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { between } from '../../utils/format.js'\nimport { hSlot, hDir } from '../../utils/private/render.js'\nimport { layoutKey, emptyRenderFn } from '../../utils/private/symbols.js'\n\nconst duration = 150\n\nexport default createComponent({\n  name: 'QDrawer',\n\n  inheritAttrs: false,\n\n  props: {\n    ...useModelToggleProps,\n    ...useDarkProps,\n\n    side: {\n      type: String,\n      default: 'left',\n      validator: v => [ 'left', 'right' ].includes(v)\n    },\n\n    width: {\n      type: Number,\n      default: 300\n    },\n\n    mini: Boolean,\n    miniToOverlay: Boolean,\n    miniWidth: {\n      type: Number,\n      default: 57\n    },\n    noMiniAnimation: Boolean,\n\n    breakpoint: {\n      type: Number,\n      default: 1023\n    },\n    showIfAbove: Boolean,\n\n    behavior: {\n      type: String,\n      validator: v => [ 'default', 'desktop', 'mobile' ].includes(v),\n      default: 'default'\n    },\n\n    bordered: Boolean,\n    elevated: Boolean,\n\n    overlay: Boolean,\n    persistent: Boolean,\n    noSwipeOpen: Boolean,\n    noSwipeClose: Boolean,\n    noSwipeBackdrop: Boolean\n  },\n\n  emits: [\n    ...useModelToggleEmits,\n    'onLayout', 'miniState'\n  ],\n\n  setup (props, { slots, emit, attrs }) {\n    const vm = getCurrentInstance()\n    const { proxy: { $q } } = vm\n\n    const isDark = useDark(props, $q)\n    const { preventBodyScroll } = usePreventScroll()\n    const { registerTimeout, removeTimeout } = useTimeout()\n\n    const $layout = inject(layoutKey, emptyRenderFn)\n    if ($layout === emptyRenderFn) {\n      console.error('QDrawer needs to be child of QLayout')\n      return emptyRenderFn\n    }\n\n    let lastDesktopState, timerMini = null, layoutTotalWidthWatcher\n\n    const belowBreakpoint = ref(\n      props.behavior === 'mobile'\n      || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n    )\n\n    const isMini = computed(() =>\n      props.mini === true && belowBreakpoint.value !== true\n    )\n\n    const size = computed(() => (\n      isMini.value === true\n        ? props.miniWidth\n        : props.width\n    ))\n\n    const showing = ref(\n      props.showIfAbove === true && belowBreakpoint.value === false\n        ? true\n        : props.modelValue === true\n    )\n\n    const hideOnRouteChange = computed(() =>\n      props.persistent !== true\n      && (belowBreakpoint.value === true || onScreenOverlay.value === true)\n    )\n\n    function handleShow (evt, noEvent) {\n      addToHistory()\n\n      evt !== false && $layout.animate()\n      applyPosition(0)\n\n      if (belowBreakpoint.value === true) {\n        const otherInstance = $layout.instances[ otherSide.value ]\n        if (otherInstance !== void 0 && otherInstance.belowBreakpoint === true) {\n          otherInstance.hide(false)\n        }\n\n        applyBackdrop(1)\n        $layout.isContainer.value !== true && preventBodyScroll(true)\n      }\n      else {\n        applyBackdrop(0)\n        evt !== false && setScrollable(false)\n      }\n\n      registerTimeout(() => {\n        evt !== false && setScrollable(true)\n        noEvent !== true && emit('show', evt)\n      }, duration)\n    }\n\n    function handleHide (evt, noEvent) {\n      removeFromHistory()\n\n      evt !== false && $layout.animate()\n\n      applyBackdrop(0)\n      applyPosition(stateDirection.value * size.value)\n\n      cleanup()\n\n      if (noEvent !== true) {\n        registerTimeout(() => { emit('hide', evt) }, duration)\n      }\n      else {\n        removeTimeout()\n      }\n    }\n\n    const { show, hide } = useModelToggle({\n      showing,\n      hideOnRouteChange,\n      handleShow,\n      handleHide\n    })\n\n    const { addToHistory, removeFromHistory } = useHistory(showing, hide, hideOnRouteChange)\n\n    const instance = {\n      belowBreakpoint,\n      hide\n    }\n\n    const rightSide = computed(() => props.side === 'right')\n\n    const stateDirection = computed(() =>\n      ($q.lang.rtl === true ? -1 : 1) * (rightSide.value === true ? 1 : -1)\n    )\n\n    const flagBackdropBg = ref(0)\n    const flagPanning = ref(false)\n    const flagMiniAnimate = ref(false)\n    const flagContentPosition = ref( // starting with \"hidden\" for SSR\n      size.value * stateDirection.value\n    )\n\n    const otherSide = computed(() => (rightSide.value === true ? 'left' : 'right'))\n    const offset = computed(() => (\n      showing.value === true && belowBreakpoint.value === false && props.overlay === false\n        ? (props.miniToOverlay === true ? props.miniWidth : size.value)\n        : 0\n    ))\n\n    const fixed = computed(() =>\n      props.overlay === true\n      || props.miniToOverlay === true\n      || $layout.view.value.indexOf(rightSide.value ? 'R' : 'L') > -1\n      || ($q.platform.is.ios === true && $layout.isContainer.value === true)\n    )\n\n    const onLayout = computed(() =>\n      props.overlay === false\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const onScreenOverlay = computed(() =>\n      props.overlay === true\n      && showing.value === true\n      && belowBreakpoint.value === false\n    )\n\n    const backdropClass = computed(() =>\n      'fullscreen q-drawer__backdrop'\n      + (showing.value === false && flagPanning.value === false ? ' hidden' : '')\n    )\n\n    const backdropStyle = computed(() => ({\n      backgroundColor: `rgba(0,0,0,${ flagBackdropBg.value * 0.4 })`\n    }))\n\n    const headerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.top[ 2 ] === 'r'\n        : $layout.rows.value.top[ 0 ] === 'l'\n    ))\n\n    const footerSlot = computed(() => (\n      rightSide.value === true\n        ? $layout.rows.value.bottom[ 2 ] === 'r'\n        : $layout.rows.value.bottom[ 0 ] === 'l'\n    ))\n\n    const aboveStyle = computed(() => {\n      const css = {}\n\n      if ($layout.header.space === true && headerSlot.value === false) {\n        if (fixed.value === true) {\n          css.top = `${ $layout.header.offset }px`\n        }\n        else if ($layout.header.space === true) {\n          css.top = `${ $layout.header.size }px`\n        }\n      }\n\n      if ($layout.footer.space === true && footerSlot.value === false) {\n        if (fixed.value === true) {\n          css.bottom = `${ $layout.footer.offset }px`\n        }\n        else if ($layout.footer.space === true) {\n          css.bottom = `${ $layout.footer.size }px`\n        }\n      }\n\n      return css\n    })\n\n    const style = computed(() => {\n      const style = {\n        width: `${ size.value }px`,\n        transform: `translateX(${ flagContentPosition.value }px)`\n      }\n\n      return belowBreakpoint.value === true\n        ? style\n        : Object.assign(style, aboveStyle.value)\n    })\n\n    const contentClass = computed(() =>\n      'q-drawer__content fit '\n      + ($layout.isContainer.value !== true ? 'scroll' : 'overflow-auto')\n    )\n\n    const classes = computed(() =>\n      `q-drawer q-drawer--${ props.side }`\n      + (flagMiniAnimate.value === true ? ' q-drawer--mini-animate' : '')\n      + (props.bordered === true ? ' q-drawer--bordered' : '')\n      + (isDark.value === true ? ' q-drawer--dark q-dark' : '')\n      + (\n        flagPanning.value === true\n          ? ' no-transition'\n          : (showing.value === true ? '' : ' q-layout--prevent-focus')\n      )\n      + (\n        belowBreakpoint.value === true\n          ? ' fixed q-drawer--on-top q-drawer--mobile q-drawer--top-padding'\n          : ` q-drawer--${ isMini.value === true ? 'mini' : 'standard' }`\n          + (fixed.value === true || onLayout.value !== true ? ' fixed' : '')\n          + (props.overlay === true || props.miniToOverlay === true ? ' q-drawer--on-top' : '')\n          + (headerSlot.value === true ? ' q-drawer--top-padding' : '')\n      )\n    )\n\n    const openDirective = computed(() => {\n      // if props.noSwipeOpen !== true\n      const dir = $q.lang.rtl === true ? props.side : otherSide.value\n\n      return [ [\n        TouchPan,\n        onOpenPan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const contentCloseDirective = computed(() => {\n      // if belowBreakpoint.value === true && props.noSwipeClose !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true\n        }\n      ] ]\n    })\n\n    const backdropCloseDirective = computed(() => {\n      // if showing.value === true && props.noSwipeBackdrop !== true\n      const dir = $q.lang.rtl === true ? otherSide.value : props.side\n\n      return [ [\n        TouchPan,\n        onClosePan,\n        void 0,\n        {\n          [ dir ]: true,\n          mouse: true,\n          mouseAllDir: true\n        }\n      ] ]\n    })\n\n    function updateBelowBreakpoint () {\n      updateLocal(belowBreakpoint, (\n        props.behavior === 'mobile'\n        || (props.behavior !== 'desktop' && $layout.totalWidth.value <= props.breakpoint)\n      ))\n    }\n\n    watch(belowBreakpoint, val => {\n      if (val === true) { // from lg to xs\n        lastDesktopState = showing.value\n        showing.value === true && hide(false)\n      }\n      else if (\n        props.overlay === false\n        && props.behavior !== 'mobile'\n        && lastDesktopState !== false\n      ) { // from xs to lg\n        if (showing.value === true) {\n          applyPosition(0)\n          applyBackdrop(0)\n          cleanup()\n        }\n        else {\n          show(false)\n        }\n      }\n    })\n\n    watch(() => props.side, (newSide, oldSide) => {\n      if ($layout.instances[ oldSide ] === instance) {\n        $layout.instances[ oldSide ] = void 0\n        $layout[ oldSide ].space = false\n        $layout[ oldSide ].offset = 0\n      }\n\n      $layout.instances[ newSide ] = instance\n      $layout[ newSide ].size = size.value\n      $layout[ newSide ].space = onLayout.value\n      $layout[ newSide ].offset = offset.value\n    })\n\n    watch($layout.totalWidth, () => {\n      if ($layout.isContainer.value === true || document.qScrollPrevented !== true) {\n        updateBelowBreakpoint()\n      }\n    })\n\n    watch(\n      () => props.behavior + props.breakpoint,\n      updateBelowBreakpoint\n    )\n\n    watch($layout.isContainer, val => {\n      showing.value === true && preventBodyScroll(val !== true)\n      val === true && updateBelowBreakpoint()\n    })\n\n    watch($layout.scrollbarWidth, () => {\n      applyPosition(showing.value === true ? 0 : void 0)\n    })\n\n    watch(offset, val => { updateLayout('offset', val) })\n\n    watch(onLayout, val => {\n      emit('onLayout', val)\n      updateLayout('space', val)\n    })\n\n    watch(rightSide, () => { applyPosition() })\n\n    watch(size, val => {\n      applyPosition()\n      updateSizeOnLayout(props.miniToOverlay, val)\n    })\n\n    watch(() => props.miniToOverlay, val => {\n      updateSizeOnLayout(val, size.value)\n    })\n\n    watch(() => $q.lang.rtl, () => { applyPosition() })\n\n    watch(() => props.mini, () => {\n      if (props.noMiniAnimation) return\n      if (props.modelValue === true) {\n        animateMini()\n        $layout.animate()\n      }\n    })\n\n    watch(isMini, val => { emit('miniState', val) })\n\n    function applyPosition (position) {\n      if (position === void 0) {\n        nextTick(() => {\n          position = showing.value === true ? 0 : size.value\n          applyPosition(stateDirection.value * position)\n        })\n      }\n      else {\n        if (\n          $layout.isContainer.value === true\n          && rightSide.value === true\n          && (belowBreakpoint.value === true || Math.abs(position) === size.value)\n        ) {\n          position += stateDirection.value * $layout.scrollbarWidth.value\n        }\n\n        flagContentPosition.value = position\n      }\n    }\n\n    function applyBackdrop (x) {\n      flagBackdropBg.value = x\n    }\n\n    function setScrollable (v) {\n      const action = v === true\n        ? 'remove'\n        : ($layout.isContainer.value !== true ? 'add' : '')\n\n      action !== '' && document.body.classList[ action ]('q-body--drawer-toggle')\n    }\n\n    function animateMini () {\n      timerMini !== null && clearTimeout(timerMini)\n\n      if (vm.proxy && vm.proxy.$el) {\n        // need to speed it up and apply it immediately,\n        // even faster than Vue's nextTick!\n        vm.proxy.$el.classList.add('q-drawer--mini-animate')\n      }\n\n      flagMiniAnimate.value = true\n      timerMini = setTimeout(() => {\n        timerMini = null\n        flagMiniAnimate.value = false\n        if (vm && vm.proxy && vm.proxy.$el) {\n          vm.proxy.$el.classList.remove('q-drawer--mini-animate')\n        }\n      }, 150)\n    }\n\n    function onOpenPan (evt) {\n      if (showing.value !== false) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been opened (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        position = between(evt.distance.x, 0, width)\n\n      if (evt.isFinal === true) {\n        const opened = position >= Math.min(75, width)\n\n        if (opened === true) {\n          show()\n        }\n        else {\n          $layout.animate()\n          applyBackdrop(0)\n          applyPosition(stateDirection.value * width)\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(\n        ($q.lang.rtl === true ? rightSide.value !== true : rightSide.value)\n          ? Math.max(width - position, 0)\n          : Math.min(0, position - width)\n      )\n      applyBackdrop(\n        between(position / width, 0, 1)\n      )\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function onClosePan (evt) {\n      if (showing.value !== true) {\n        // some browsers might capture and trigger this\n        // even if Drawer has just been closed (but animation is still pending)\n        return\n      }\n\n      const\n        width = size.value,\n        dir = evt.direction === props.side,\n        position = ($q.lang.rtl === true ? dir !== true : dir)\n          ? between(evt.distance.x, 0, width)\n          : 0\n\n      if (evt.isFinal === true) {\n        const opened = Math.abs(position) < Math.min(75, width)\n\n        if (opened === true) {\n          $layout.animate()\n          applyBackdrop(1)\n          applyPosition(0)\n        }\n        else {\n          hide()\n        }\n\n        flagPanning.value = false\n        return\n      }\n\n      applyPosition(stateDirection.value * position)\n      applyBackdrop(between(1 - position / width, 0, 1))\n\n      if (evt.isFirst === true) {\n        flagPanning.value = true\n      }\n    }\n\n    function cleanup () {\n      preventBodyScroll(false)\n      setScrollable(true)\n    }\n\n    function updateLayout (prop, val) {\n      $layout.update(props.side, prop, val)\n    }\n\n    function updateLocal (prop, val) {\n      if (prop.value !== val) {\n        prop.value = val\n      }\n    }\n\n    function updateSizeOnLayout (miniToOverlay, size) {\n      updateLayout('size', miniToOverlay === true ? props.miniWidth : size)\n    }\n\n    $layout.instances[ props.side ] = instance\n    updateSizeOnLayout(props.miniToOverlay, size.value)\n    updateLayout('space', onLayout.value)\n    updateLayout('offset', offset.value)\n\n    if (\n      props.showIfAbove === true\n      && props.modelValue !== true\n      && showing.value === true\n      && props[ 'onUpdate:modelValue' ] !== void 0\n    ) {\n      emit('update:modelValue', true)\n    }\n\n    onMounted(() => {\n      emit('onLayout', onLayout.value)\n      emit('miniState', isMini.value)\n\n      lastDesktopState = props.showIfAbove === true\n\n      const fn = () => {\n        const action = showing.value === true ? handleShow : handleHide\n        action(false, true)\n      }\n\n      if ($layout.totalWidth.value !== 0) {\n        // make sure that all computed properties\n        // have been updated before calling handleShow/handleHide()\n        nextTick(fn)\n        return\n      }\n\n      layoutTotalWidthWatcher = watch($layout.totalWidth, () => {\n        layoutTotalWidthWatcher()\n        layoutTotalWidthWatcher = void 0\n\n        if (showing.value === false && props.showIfAbove === true && belowBreakpoint.value === false) {\n          show(false)\n        }\n        else {\n          fn()\n        }\n      })\n    })\n\n    onBeforeUnmount(() => {\n      layoutTotalWidthWatcher !== void 0 && layoutTotalWidthWatcher()\n\n      if (timerMini !== null) {\n        clearTimeout(timerMini)\n        timerMini = null\n      }\n\n      showing.value === true && cleanup()\n\n      if ($layout.instances[ props.side ] === instance) {\n        $layout.instances[ props.side ] = void 0\n        updateLayout('size', 0)\n        updateLayout('offset', 0)\n        updateLayout('space', false)\n      }\n    })\n\n    return () => {\n      const child = []\n\n      if (belowBreakpoint.value === true) {\n        props.noSwipeOpen === false && child.push(\n          withDirectives(\n            h('div', {\n              key: 'open',\n              class: `q-drawer__opener fixed-${ props.side }`,\n              'aria-hidden': 'true'\n            }),\n            openDirective.value\n          )\n        )\n\n        child.push(\n          hDir(\n            'div',\n            {\n              ref: 'backdrop',\n              class: backdropClass.value,\n              style: backdropStyle.value,\n              'aria-hidden': 'true',\n              onClick: hide\n            },\n            void 0,\n            'backdrop',\n            props.noSwipeBackdrop !== true && showing.value === true,\n            () => backdropCloseDirective.value\n          )\n        )\n      }\n\n      const mini = isMini.value === true && slots.mini !== void 0\n      const content = [\n        h('div', {\n          ...attrs,\n          key: '' + mini, // required otherwise Vue will not diff correctly\n          class: [\n            contentClass.value,\n            attrs.class\n          ]\n        }, mini === true\n          ? slots.mini()\n          : hSlot(slots.default)\n        )\n      ]\n\n      if (props.elevated === true && showing.value === true) {\n        content.push(\n          h('div', {\n            class: 'q-layout__shadow absolute-full overflow-hidden no-pointer-events'\n          })\n        )\n      }\n\n      child.push(\n        hDir(\n          'aside',\n          { ref: 'content', class: classes.value, style: style.value },\n          content,\n          'contentclose',\n          props.noSwipeClose !== true && belowBreakpoint.value === true,\n          () => contentCloseDirective.value\n        )\n      )\n\n      return h('div', { class: 'q-drawer-container' }, child)\n    }\n  }\n})\n"],"mappings":";AAAA,SAASA,CAAC,EAAEC,cAAc,EAAEC,GAAG,EAAEC,QAAQ,EAAEC,KAAK,EAAEC,SAAS,EAAEC,eAAe,EAAEC,QAAQ,EAAEC,MAAM,EAAEC,kBAAkB,QAAQ,KAAK;AAE/H,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,cAAc,IAAIC,mBAAmB,EAAEC,mBAAmB,QAAQ,+CAA+C;AACxH,OAAOC,gBAAgB,MAAM,iDAAiD;AAC9E,OAAOC,UAAU,MAAM,0CAA0C;AACjE,OAAOC,OAAO,IAAIC,YAAY,QAAQ,uCAAuC;AAE7E,OAAOC,QAAQ,MAAM,8BAA8B;AAEnD,SAASC,eAAe,QAAQ,+BAA+B;AAC/D,SAASC,OAAO,QAAQ,uBAAuB;AAC/C,SAASC,KAAK,EAAEC,IAAI,QAAQ,+BAA+B;AAC3D,SAASC,SAAS,EAAEC,aAAa,QAAQ,gCAAgC;AAEzE,MAAMC,QAAQ,GAAG,GAAG;AAEpB,eAAeN,eAAe,CAAC;EAC7BO,IAAI,EAAE,SAAS;EAEfC,YAAY,EAAE,KAAK;EAEnBC,KAAK,EAAE;IACL,GAAGhB,mBAAmB;IACtB,GAAGK,YAAY;IAEfY,IAAI,EAAE;MACJC,IAAI,EAAEC,MAAM;MACZC,OAAO,EAAE,MAAM;MACfC,SAAS,EAAEC,CAAC,IAAI,CAAE,MAAM,EAAE,OAAO,CAAE,CAACC,QAAQ,CAACD,CAAC;IAChD,CAAC;IAEDE,KAAK,EAAE;MACLN,IAAI,EAAEO,MAAM;MACZL,OAAO,EAAE;IACX,CAAC;IAEDM,IAAI,EAAEC,OAAO;IACbC,aAAa,EAAED,OAAO;IACtBE,SAAS,EAAE;MACTX,IAAI,EAAEO,MAAM;MACZL,OAAO,EAAE;IACX,CAAC;IACDU,eAAe,EAAEH,OAAO;IAExBI,UAAU,EAAE;MACVb,IAAI,EAAEO,MAAM;MACZL,OAAO,EAAE;IACX,CAAC;IACDY,WAAW,EAAEL,OAAO;IAEpBM,QAAQ,EAAE;MACRf,IAAI,EAAEC,MAAM;MACZE,SAAS,EAAEC,CAAC,IAAI,CAAE,SAAS,EAAE,SAAS,EAAE,QAAQ,CAAE,CAACC,QAAQ,CAACD,CAAC,CAAC;MAC9DF,OAAO,EAAE;IACX,CAAC;IAEDc,QAAQ,EAAEP,OAAO;IACjBQ,QAAQ,EAAER,OAAO;IAEjBS,OAAO,EAAET,OAAO;IAChBU,UAAU,EAAEV,OAAO;IACnBW,WAAW,EAAEX,OAAO;IACpBY,YAAY,EAAEZ,OAAO;IACrBa,eAAe,EAAEb;EACnB,CAAC;EAEDc,KAAK,EAAE,CACL,GAAGxC,mBAAmB,EACtB,UAAU,EAAE,WAAW,CACxB;EAEDyC,KAAKA,CAAE1B,KAAK,EAAE;IAAE2B,KAAK;IAAEC,IAAI;IAAEC;EAAM,CAAC,EAAE;IACpC,MAAMC,EAAE,GAAGjD,kBAAkB,EAAE;IAC/B,MAAM;MAAEkD,KAAK,EAAE;QAAEC;MAAG;IAAE,CAAC,GAAGF,EAAE;IAE5B,MAAMG,MAAM,GAAG7C,OAAO,CAACY,KAAK,EAAEgC,EAAE,CAAC;IACjC,MAAM;MAAEE;IAAkB,CAAC,GAAGhD,gBAAgB,EAAE;IAChD,MAAM;MAAEiD,eAAe;MAAEC;IAAc,CAAC,GAAGjD,UAAU,EAAE;IAEvD,MAAMkD,OAAO,GAAGzD,MAAM,CAACe,SAAS,EAAEC,aAAa,CAAC;IAChD,IAAIyC,OAAO,KAAKzC,aAAa,EAAE;MAC7B0C,OAAO,CAACC,KAAK,CAAC,sCAAsC,CAAC;MACrD,OAAO3C,aAAa;IACtB;IAEA,IAAI4C,gBAAgB;MAAEC,SAAS,GAAG,IAAI;MAAEC,uBAAuB;IAE/D,MAAMC,eAAe,GAAGrE,GAAG,CACzB0B,KAAK,CAACiB,QAAQ,KAAK,QAAQ,IACvBjB,KAAK,CAACiB,QAAQ,KAAK,SAAS,IAAIoB,OAAO,CAACO,UAAU,CAACC,KAAK,IAAI7C,KAAK,CAACe,UAAW,CAClF;IAED,MAAM+B,MAAM,GAAGvE,QAAQ,CAAC,MACtByB,KAAK,CAACU,IAAI,KAAK,IAAI,IAAIiC,eAAe,CAACE,KAAK,KAAK,IAAI,CACtD;IAED,MAAME,IAAI,GAAGxE,QAAQ,CAAC,MACpBuE,MAAM,CAACD,KAAK,KAAK,IAAI,GACjB7C,KAAK,CAACa,SAAS,GACfb,KAAK,CAACQ,KACX,CAAC;IAEF,MAAMwC,OAAO,GAAG1E,GAAG,CACjB0B,KAAK,CAACgB,WAAW,KAAK,IAAI,IAAI2B,eAAe,CAACE,KAAK,KAAK,KAAK,GACzD,IAAI,GACJ7C,KAAK,CAACiD,UAAU,KAAK,IAAI,CAC9B;IAED,MAAMC,iBAAiB,GAAG3E,QAAQ,CAAC,MACjCyB,KAAK,CAACqB,UAAU,KAAK,IAAI,KACrBsB,eAAe,CAACE,KAAK,KAAK,IAAI,IAAIM,eAAe,CAACN,KAAK,KAAK,IAAI,CAAC,CACtE;IAED,SAASO,UAAUA,CAAEC,GAAG,EAAEC,OAAO,EAAE;MACjCC,YAAY,EAAE;MAEdF,GAAG,KAAK,KAAK,IAAIhB,OAAO,CAACmB,OAAO,EAAE;MAClCC,aAAa,CAAC,CAAC,CAAC;MAEhB,IAAId,eAAe,CAACE,KAAK,KAAK,IAAI,EAAE;QAClC,MAAMa,aAAa,GAAGrB,OAAO,CAACsB,SAAS,CAAEC,SAAS,CAACf,KAAK,CAAE;QAC1D,IAAIa,aAAa,KAAK,KAAK,CAAC,IAAIA,aAAa,CAACf,eAAe,KAAK,IAAI,EAAE;UACtEe,aAAa,CAACG,IAAI,CAAC,KAAK,CAAC;QAC3B;QAEAC,aAAa,CAAC,CAAC,CAAC;QAChBzB,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAI,IAAIX,iBAAiB,CAAC,IAAI,CAAC;MAC/D,CAAC,MACI;QACH4B,aAAa,CAAC,CAAC,CAAC;QAChBT,GAAG,KAAK,KAAK,IAAIW,aAAa,CAAC,KAAK,CAAC;MACvC;MAEA7B,eAAe,CAAC,MAAM;QACpBkB,GAAG,KAAK,KAAK,IAAIW,aAAa,CAAC,IAAI,CAAC;QACpCV,OAAO,KAAK,IAAI,IAAI1B,IAAI,CAAC,MAAM,EAAEyB,GAAG,CAAC;MACvC,CAAC,EAAExD,QAAQ,CAAC;IACd;IAEA,SAASoE,UAAUA,CAAEZ,GAAG,EAAEC,OAAO,EAAE;MACjCY,iBAAiB,EAAE;MAEnBb,GAAG,KAAK,KAAK,IAAIhB,OAAO,CAACmB,OAAO,EAAE;MAElCM,aAAa,CAAC,CAAC,CAAC;MAChBL,aAAa,CAACU,cAAc,CAACtB,KAAK,GAAGE,IAAI,CAACF,KAAK,CAAC;MAEhDuB,OAAO,EAAE;MAET,IAAId,OAAO,KAAK,IAAI,EAAE;QACpBnB,eAAe,CAAC,MAAM;UAAEP,IAAI,CAAC,MAAM,EAAEyB,GAAG,CAAC;QAAC,CAAC,EAAExD,QAAQ,CAAC;MACxD,CAAC,MACI;QACHuC,aAAa,EAAE;MACjB;IACF;IAEA,MAAM;MAAEiC,IAAI;MAAER;IAAK,CAAC,GAAG9E,cAAc,CAAC;MACpCiE,OAAO;MACPE,iBAAiB;MACjBE,UAAU;MACVa;IACF,CAAC,CAAC;IAEF,MAAM;MAAEV,YAAY;MAAEW;IAAkB,CAAC,GAAGpF,UAAU,CAACkE,OAAO,EAAEa,IAAI,EAAEX,iBAAiB,CAAC;IAExF,MAAMoB,QAAQ,GAAG;MACf3B,eAAe;MACfkB;IACF,CAAC;IAED,MAAMU,SAAS,GAAGhG,QAAQ,CAAC,MAAMyB,KAAK,CAACC,IAAI,KAAK,OAAO,CAAC;IAExD,MAAMkE,cAAc,GAAG5F,QAAQ,CAAC,MAC9B,CAACyD,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAG,CAAC,CAAC,GAAG,CAAC,KAAKF,SAAS,CAAC1B,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CACtE;IAED,MAAM6B,cAAc,GAAGpG,GAAG,CAAC,CAAC,CAAC;IAC7B,MAAMqG,WAAW,GAAGrG,GAAG,CAAC,KAAK,CAAC;IAC9B,MAAMsG,eAAe,GAAGtG,GAAG,CAAC,KAAK,CAAC;IAClC,MAAMuG,mBAAmB,GAAGvG,GAAG;IAAE;IAC/ByE,IAAI,CAACF,KAAK,GAAGsB,cAAc,CAACtB,KAAK,CAClC;IAED,MAAMe,SAAS,GAAGrF,QAAQ,CAAC,MAAOgG,SAAS,CAAC1B,KAAK,KAAK,IAAI,GAAG,MAAM,GAAG,OAAQ,CAAC;IAC/E,MAAMiC,MAAM,GAAGvG,QAAQ,CAAC,MACtByE,OAAO,CAACH,KAAK,KAAK,IAAI,IAAIF,eAAe,CAACE,KAAK,KAAK,KAAK,IAAI7C,KAAK,CAACoB,OAAO,KAAK,KAAK,GAC/EpB,KAAK,CAACY,aAAa,KAAK,IAAI,GAAGZ,KAAK,CAACa,SAAS,GAAGkC,IAAI,CAACF,KAAK,GAC5D,CACL,CAAC;IAEF,MAAMkC,KAAK,GAAGxG,QAAQ,CAAC,MACrByB,KAAK,CAACoB,OAAO,KAAK,IAAI,IACnBpB,KAAK,CAACY,aAAa,KAAK,IAAI,IAC5ByB,OAAO,CAAC2C,IAAI,CAACnC,KAAK,CAACoC,OAAO,CAACV,SAAS,CAAC1B,KAAK,GAAG,GAAG,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC,IAC3Db,EAAE,CAACkD,QAAQ,CAACC,EAAE,CAACC,GAAG,KAAK,IAAI,IAAI/C,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAK,CACvE;IAED,MAAMwC,QAAQ,GAAG9G,QAAQ,CAAC,MACxByB,KAAK,CAACoB,OAAO,KAAK,KAAK,IACpB4B,OAAO,CAACH,KAAK,KAAK,IAAI,IACtBF,eAAe,CAACE,KAAK,KAAK,KAAK,CACnC;IAED,MAAMM,eAAe,GAAG5E,QAAQ,CAAC,MAC/ByB,KAAK,CAACoB,OAAO,KAAK,IAAI,IACnB4B,OAAO,CAACH,KAAK,KAAK,IAAI,IACtBF,eAAe,CAACE,KAAK,KAAK,KAAK,CACnC;IAED,MAAMyC,aAAa,GAAG/G,QAAQ,CAAC,MAC7B,+BAA+B,IAC5ByE,OAAO,CAACH,KAAK,KAAK,KAAK,IAAI8B,WAAW,CAAC9B,KAAK,KAAK,KAAK,GAAG,SAAS,GAAG,EAAE,CAAC,CAC5E;IAED,MAAM0C,aAAa,GAAGhH,QAAQ,CAAC,OAAO;MACpCiH,eAAe,EAAG,cAAcd,cAAc,CAAC7B,KAAK,GAAG,GAAK;IAC9D,CAAC,CAAC,CAAC;IAEH,MAAM4C,UAAU,GAAGlH,QAAQ,CAAC,MAC1BgG,SAAS,CAAC1B,KAAK,KAAK,IAAI,GACpBR,OAAO,CAACqD,IAAI,CAAC7C,KAAK,CAAC8C,GAAG,CAAE,CAAC,CAAE,KAAK,GAAG,GACnCtD,OAAO,CAACqD,IAAI,CAAC7C,KAAK,CAAC8C,GAAG,CAAE,CAAC,CAAE,KAAK,GACrC,CAAC;IAEF,MAAMC,UAAU,GAAGrH,QAAQ,CAAC,MAC1BgG,SAAS,CAAC1B,KAAK,KAAK,IAAI,GACpBR,OAAO,CAACqD,IAAI,CAAC7C,KAAK,CAACgD,MAAM,CAAE,CAAC,CAAE,KAAK,GAAG,GACtCxD,OAAO,CAACqD,IAAI,CAAC7C,KAAK,CAACgD,MAAM,CAAE,CAAC,CAAE,KAAK,GACxC,CAAC;IAEF,MAAMC,UAAU,GAAGvH,QAAQ,CAAC,MAAM;MAChC,MAAMwH,GAAG,GAAG,CAAC,CAAC;MAEd,IAAI1D,OAAO,CAAC2D,MAAM,CAACC,KAAK,KAAK,IAAI,IAAIR,UAAU,CAAC5C,KAAK,KAAK,KAAK,EAAE;QAC/D,IAAIkC,KAAK,CAAClC,KAAK,KAAK,IAAI,EAAE;UACxBkD,GAAG,CAACJ,GAAG,GAAI,GAAGtD,OAAO,CAAC2D,MAAM,CAAClB,MAAQ,IAAG;QAC1C,CAAC,MACI,IAAIzC,OAAO,CAAC2D,MAAM,CAACC,KAAK,KAAK,IAAI,EAAE;UACtCF,GAAG,CAACJ,GAAG,GAAI,GAAGtD,OAAO,CAAC2D,MAAM,CAACjD,IAAM,IAAG;QACxC;MACF;MAEA,IAAIV,OAAO,CAAC6D,MAAM,CAACD,KAAK,KAAK,IAAI,IAAIL,UAAU,CAAC/C,KAAK,KAAK,KAAK,EAAE;QAC/D,IAAIkC,KAAK,CAAClC,KAAK,KAAK,IAAI,EAAE;UACxBkD,GAAG,CAACF,MAAM,GAAI,GAAGxD,OAAO,CAAC6D,MAAM,CAACpB,MAAQ,IAAG;QAC7C,CAAC,MACI,IAAIzC,OAAO,CAAC6D,MAAM,CAACD,KAAK,KAAK,IAAI,EAAE;UACtCF,GAAG,CAACF,MAAM,GAAI,GAAGxD,OAAO,CAAC6D,MAAM,CAACnD,IAAM,IAAG;QAC3C;MACF;MAEA,OAAOgD,GAAG;IACZ,CAAC,CAAC;IAEF,MAAMI,KAAK,GAAG5H,QAAQ,CAAC,MAAM;MAC3B,MAAM4H,KAAK,GAAG;QACZ3F,KAAK,EAAG,GAAGuC,IAAI,CAACF,KAAO,IAAG;QAC1BuD,SAAS,EAAG,cAAcvB,mBAAmB,CAAChC,KAAO;MACvD,CAAC;MAED,OAAOF,eAAe,CAACE,KAAK,KAAK,IAAI,GACjCsD,KAAK,GACLE,MAAM,CAACC,MAAM,CAACH,KAAK,EAAEL,UAAU,CAACjD,KAAK,CAAC;IAC5C,CAAC,CAAC;IAEF,MAAM0D,YAAY,GAAGhI,QAAQ,CAAC,MAC5B,wBAAwB,IACrB8D,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAI,GAAG,QAAQ,GAAG,eAAe,CAAC,CACpE;IAED,MAAM2D,OAAO,GAAGjI,QAAQ,CAAC,MACtB,sBAAsByB,KAAK,CAACC,IAAM,EAAC,IACjC2E,eAAe,CAAC/B,KAAK,KAAK,IAAI,GAAG,yBAAyB,GAAG,EAAE,CAAC,IAChE7C,KAAK,CAACkB,QAAQ,KAAK,IAAI,GAAG,qBAAqB,GAAG,EAAE,CAAC,IACrDe,MAAM,CAACY,KAAK,KAAK,IAAI,GAAG,wBAAwB,GAAG,EAAE,CAAC,IAEvD8B,WAAW,CAAC9B,KAAK,KAAK,IAAI,GACtB,gBAAgB,GACfG,OAAO,CAACH,KAAK,KAAK,IAAI,GAAG,EAAE,GAAG,0BAA2B,CAC/D,IAECF,eAAe,CAACE,KAAK,KAAK,IAAI,GAC1B,gEAAgE,GAC/D,cAAcC,MAAM,CAACD,KAAK,KAAK,IAAI,GAAG,MAAM,GAAG,UAAY,EAAC,IAC5DkC,KAAK,CAAClC,KAAK,KAAK,IAAI,IAAIwC,QAAQ,CAACxC,KAAK,KAAK,IAAI,GAAG,QAAQ,GAAG,EAAE,CAAC,IAChE7C,KAAK,CAACoB,OAAO,KAAK,IAAI,IAAIpB,KAAK,CAACY,aAAa,KAAK,IAAI,GAAG,mBAAmB,GAAG,EAAE,CAAC,IAClF6E,UAAU,CAAC5C,KAAK,KAAK,IAAI,GAAG,wBAAwB,GAAG,EAAE,CAAC,CAChE,CACF;IAED,MAAM4D,aAAa,GAAGlI,QAAQ,CAAC,MAAM;MACnC;MACA,MAAMmI,GAAG,GAAG1E,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAGzE,KAAK,CAACC,IAAI,GAAG2D,SAAS,CAACf,KAAK;MAE/D,OAAO,CAAE,CACPvD,QAAQ,EACRqH,SAAS,EACT,KAAK,CAAC,EACN;QACE,CAAED,GAAG,GAAI,IAAI;QACbE,KAAK,EAAE;MACT,CAAC,CACF,CAAE;IACL,CAAC,CAAC;IAEF,MAAMC,qBAAqB,GAAGtI,QAAQ,CAAC,MAAM;MAC3C;MACA,MAAMmI,GAAG,GAAG1E,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAGb,SAAS,CAACf,KAAK,GAAG7C,KAAK,CAACC,IAAI;MAE/D,OAAO,CAAE,CACPX,QAAQ,EACRwH,UAAU,EACV,KAAK,CAAC,EACN;QACE,CAAEJ,GAAG,GAAI,IAAI;QACbE,KAAK,EAAE;MACT,CAAC,CACF,CAAE;IACL,CAAC,CAAC;IAEF,MAAMG,sBAAsB,GAAGxI,QAAQ,CAAC,MAAM;MAC5C;MACA,MAAMmI,GAAG,GAAG1E,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAGb,SAAS,CAACf,KAAK,GAAG7C,KAAK,CAACC,IAAI;MAE/D,OAAO,CAAE,CACPX,QAAQ,EACRwH,UAAU,EACV,KAAK,CAAC,EACN;QACE,CAAEJ,GAAG,GAAI,IAAI;QACbE,KAAK,EAAE,IAAI;QACXI,WAAW,EAAE;MACf,CAAC,CACF,CAAE;IACL,CAAC,CAAC;IAEF,SAASC,qBAAqBA,CAAA,EAAI;MAChCC,WAAW,CAACvE,eAAe,EACzB3C,KAAK,CAACiB,QAAQ,KAAK,QAAQ,IACvBjB,KAAK,CAACiB,QAAQ,KAAK,SAAS,IAAIoB,OAAO,CAACO,UAAU,CAACC,KAAK,IAAI7C,KAAK,CAACe,UAAW,CACjF;IACJ;IAEAvC,KAAK,CAACmE,eAAe,EAAEwE,GAAG,IAAI;MAC5B,IAAIA,GAAG,KAAK,IAAI,EAAE;QAAE;QAClB3E,gBAAgB,GAAGQ,OAAO,CAACH,KAAK;QAChCG,OAAO,CAACH,KAAK,KAAK,IAAI,IAAIgB,IAAI,CAAC,KAAK,CAAC;MACvC,CAAC,MACI,IACH7D,KAAK,CAACoB,OAAO,KAAK,KAAK,IACpBpB,KAAK,CAACiB,QAAQ,KAAK,QAAQ,IAC3BuB,gBAAgB,KAAK,KAAK,EAC7B;QAAE;QACF,IAAIQ,OAAO,CAACH,KAAK,KAAK,IAAI,EAAE;UAC1BY,aAAa,CAAC,CAAC,CAAC;UAChBK,aAAa,CAAC,CAAC,CAAC;UAChBM,OAAO,EAAE;QACX,CAAC,MACI;UACHC,IAAI,CAAC,KAAK,CAAC;QACb;MACF;IACF,CAAC,CAAC;IAEF7F,KAAK,CAAC,MAAMwB,KAAK,CAACC,IAAI,EAAE,CAACmH,OAAO,EAAEC,OAAO,KAAK;MAC5C,IAAIhF,OAAO,CAACsB,SAAS,CAAE0D,OAAO,CAAE,KAAK/C,QAAQ,EAAE;QAC7CjC,OAAO,CAACsB,SAAS,CAAE0D,OAAO,CAAE,GAAG,KAAK,CAAC;QACrChF,OAAO,CAAEgF,OAAO,CAAE,CAACpB,KAAK,GAAG,KAAK;QAChC5D,OAAO,CAAEgF,OAAO,CAAE,CAACvC,MAAM,GAAG,CAAC;MAC/B;MAEAzC,OAAO,CAACsB,SAAS,CAAEyD,OAAO,CAAE,GAAG9C,QAAQ;MACvCjC,OAAO,CAAE+E,OAAO,CAAE,CAACrE,IAAI,GAAGA,IAAI,CAACF,KAAK;MACpCR,OAAO,CAAE+E,OAAO,CAAE,CAACnB,KAAK,GAAGZ,QAAQ,CAACxC,KAAK;MACzCR,OAAO,CAAE+E,OAAO,CAAE,CAACtC,MAAM,GAAGA,MAAM,CAACjC,KAAK;IAC1C,CAAC,CAAC;IAEFrE,KAAK,CAAC6D,OAAO,CAACO,UAAU,EAAE,MAAM;MAC9B,IAAIP,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAI,IAAIyE,QAAQ,CAACC,gBAAgB,KAAK,IAAI,EAAE;QAC5EN,qBAAqB,EAAE;MACzB;IACF,CAAC,CAAC;IAEFzI,KAAK,CACH,MAAMwB,KAAK,CAACiB,QAAQ,GAAGjB,KAAK,CAACe,UAAU,EACvCkG,qBAAqB,CACtB;IAEDzI,KAAK,CAAC6D,OAAO,CAAC0B,WAAW,EAAEoD,GAAG,IAAI;MAChCnE,OAAO,CAACH,KAAK,KAAK,IAAI,IAAIX,iBAAiB,CAACiF,GAAG,KAAK,IAAI,CAAC;MACzDA,GAAG,KAAK,IAAI,IAAIF,qBAAqB,EAAE;IACzC,CAAC,CAAC;IAEFzI,KAAK,CAAC6D,OAAO,CAACmF,cAAc,EAAE,MAAM;MAClC/D,aAAa,CAACT,OAAO,CAACH,KAAK,KAAK,IAAI,GAAG,CAAC,GAAG,KAAK,CAAC,CAAC;IACpD,CAAC,CAAC;IAEFrE,KAAK,CAACsG,MAAM,EAAEqC,GAAG,IAAI;MAAEM,YAAY,CAAC,QAAQ,EAAEN,GAAG,CAAC;IAAC,CAAC,CAAC;IAErD3I,KAAK,CAAC6G,QAAQ,EAAE8B,GAAG,IAAI;MACrBvF,IAAI,CAAC,UAAU,EAAEuF,GAAG,CAAC;MACrBM,YAAY,CAAC,OAAO,EAAEN,GAAG,CAAC;IAC5B,CAAC,CAAC;IAEF3I,KAAK,CAAC+F,SAAS,EAAE,MAAM;MAAEd,aAAa,EAAE;IAAC,CAAC,CAAC;IAE3CjF,KAAK,CAACuE,IAAI,EAAEoE,GAAG,IAAI;MACjB1D,aAAa,EAAE;MACfiE,kBAAkB,CAAC1H,KAAK,CAACY,aAAa,EAAEuG,GAAG,CAAC;IAC9C,CAAC,CAAC;IAEF3I,KAAK,CAAC,MAAMwB,KAAK,CAACY,aAAa,EAAEuG,GAAG,IAAI;MACtCO,kBAAkB,CAACP,GAAG,EAAEpE,IAAI,CAACF,KAAK,CAAC;IACrC,CAAC,CAAC;IAEFrE,KAAK,CAAC,MAAMwD,EAAE,CAACwC,IAAI,CAACC,GAAG,EAAE,MAAM;MAAEhB,aAAa,EAAE;IAAC,CAAC,CAAC;IAEnDjF,KAAK,CAAC,MAAMwB,KAAK,CAACU,IAAI,EAAE,MAAM;MAC5B,IAAIV,KAAK,CAACc,eAAe,EAAE;MAC3B,IAAId,KAAK,CAACiD,UAAU,KAAK,IAAI,EAAE;QAC7B0E,WAAW,EAAE;QACbtF,OAAO,CAACmB,OAAO,EAAE;MACnB;IACF,CAAC,CAAC;IAEFhF,KAAK,CAACsE,MAAM,EAAEqE,GAAG,IAAI;MAAEvF,IAAI,CAAC,WAAW,EAAEuF,GAAG,CAAC;IAAC,CAAC,CAAC;IAEhD,SAAS1D,aAAaA,CAAEmE,QAAQ,EAAE;MAChC,IAAIA,QAAQ,KAAK,KAAK,CAAC,EAAE;QACvBjJ,QAAQ,CAAC,MAAM;UACbiJ,QAAQ,GAAG5E,OAAO,CAACH,KAAK,KAAK,IAAI,GAAG,CAAC,GAAGE,IAAI,CAACF,KAAK;UAClDY,aAAa,CAACU,cAAc,CAACtB,KAAK,GAAG+E,QAAQ,CAAC;QAChD,CAAC,CAAC;MACJ,CAAC,MACI;QACH,IACEvF,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAI,IAC/B0B,SAAS,CAAC1B,KAAK,KAAK,IAAI,KACvBF,eAAe,CAACE,KAAK,KAAK,IAAI,IAAIgF,IAAI,CAACC,GAAG,CAACF,QAAQ,CAAC,KAAK7E,IAAI,CAACF,KAAK,CAAC,EACxE;UACA+E,QAAQ,IAAIzD,cAAc,CAACtB,KAAK,GAAGR,OAAO,CAACmF,cAAc,CAAC3E,KAAK;QACjE;QAEAgC,mBAAmB,CAAChC,KAAK,GAAG+E,QAAQ;MACtC;IACF;IAEA,SAAS9D,aAAaA,CAAEiE,CAAC,EAAE;MACzBrD,cAAc,CAAC7B,KAAK,GAAGkF,CAAC;IAC1B;IAEA,SAAS/D,aAAaA,CAAE1D,CAAC,EAAE;MACzB,MAAM0H,MAAM,GAAG1H,CAAC,KAAK,IAAI,GACrB,QAAQ,GACP+B,OAAO,CAAC0B,WAAW,CAAClB,KAAK,KAAK,IAAI,GAAG,KAAK,GAAG,EAAG;MAErDmF,MAAM,KAAK,EAAE,IAAIV,QAAQ,CAACW,IAAI,CAACC,SAAS,CAAEF,MAAM,CAAE,CAAC,uBAAuB,CAAC;IAC7E;IAEA,SAASL,WAAWA,CAAA,EAAI;MACtBlF,SAAS,KAAK,IAAI,IAAI0F,YAAY,CAAC1F,SAAS,CAAC;MAE7C,IAAIX,EAAE,CAACC,KAAK,IAAID,EAAE,CAACC,KAAK,CAACqG,GAAG,EAAE;QAC5B;QACA;QACAtG,EAAE,CAACC,KAAK,CAACqG,GAAG,CAACF,SAAS,CAACG,GAAG,CAAC,wBAAwB,CAAC;MACtD;MAEAzD,eAAe,CAAC/B,KAAK,GAAG,IAAI;MAC5BJ,SAAS,GAAG6F,UAAU,CAAC,MAAM;QAC3B7F,SAAS,GAAG,IAAI;QAChBmC,eAAe,CAAC/B,KAAK,GAAG,KAAK;QAC7B,IAAIf,EAAE,IAAIA,EAAE,CAACC,KAAK,IAAID,EAAE,CAACC,KAAK,CAACqG,GAAG,EAAE;UAClCtG,EAAE,CAACC,KAAK,CAACqG,GAAG,CAACF,SAAS,CAACK,MAAM,CAAC,wBAAwB,CAAC;QACzD;MACF,CAAC,EAAE,GAAG,CAAC;IACT;IAEA,SAAS5B,SAASA,CAAEtD,GAAG,EAAE;MACvB,IAAIL,OAAO,CAACH,KAAK,KAAK,KAAK,EAAE;QAC3B;QACA;QACA;MACF;MAEA,MACErC,KAAK,GAAGuC,IAAI,CAACF,KAAK;QAClB+E,QAAQ,GAAGpI,OAAO,CAAC6D,GAAG,CAACmF,QAAQ,CAACT,CAAC,EAAE,CAAC,EAAEvH,KAAK,CAAC;MAE9C,IAAI6C,GAAG,CAACoF,OAAO,KAAK,IAAI,EAAE;QACxB,MAAMC,MAAM,GAAGd,QAAQ,IAAIC,IAAI,CAACc,GAAG,CAAC,EAAE,EAAEnI,KAAK,CAAC;QAE9C,IAAIkI,MAAM,KAAK,IAAI,EAAE;UACnBrE,IAAI,EAAE;QACR,CAAC,MACI;UACHhC,OAAO,CAACmB,OAAO,EAAE;UACjBM,aAAa,CAAC,CAAC,CAAC;UAChBL,aAAa,CAACU,cAAc,CAACtB,KAAK,GAAGrC,KAAK,CAAC;QAC7C;QAEAmE,WAAW,CAAC9B,KAAK,GAAG,KAAK;QACzB;MACF;MAEAY,aAAa,CACX,CAACzB,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAGF,SAAS,CAAC1B,KAAK,KAAK,IAAI,GAAG0B,SAAS,CAAC1B,KAAK,IAC9DgF,IAAI,CAACe,GAAG,CAACpI,KAAK,GAAGoH,QAAQ,EAAE,CAAC,CAAC,GAC7BC,IAAI,CAACc,GAAG,CAAC,CAAC,EAAEf,QAAQ,GAAGpH,KAAK,CAAC,CAClC;MACDsD,aAAa,CACXtE,OAAO,CAACoI,QAAQ,GAAGpH,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAChC;MAED,IAAI6C,GAAG,CAACwF,OAAO,KAAK,IAAI,EAAE;QACxBlE,WAAW,CAAC9B,KAAK,GAAG,IAAI;MAC1B;IACF;IAEA,SAASiE,UAAUA,CAAEzD,GAAG,EAAE;MACxB,IAAIL,OAAO,CAACH,KAAK,KAAK,IAAI,EAAE;QAC1B;QACA;QACA;MACF;MAEA,MACErC,KAAK,GAAGuC,IAAI,CAACF,KAAK;QAClB6D,GAAG,GAAGrD,GAAG,CAACyF,SAAS,KAAK9I,KAAK,CAACC,IAAI;QAClC2H,QAAQ,GAAG,CAAC5F,EAAE,CAACwC,IAAI,CAACC,GAAG,KAAK,IAAI,GAAGiC,GAAG,KAAK,IAAI,GAAGA,GAAG,IACjDlH,OAAO,CAAC6D,GAAG,CAACmF,QAAQ,CAACT,CAAC,EAAE,CAAC,EAAEvH,KAAK,CAAC,GACjC,CAAC;MAEP,IAAI6C,GAAG,CAACoF,OAAO,KAAK,IAAI,EAAE;QACxB,MAAMC,MAAM,GAAGb,IAAI,CAACC,GAAG,CAACF,QAAQ,CAAC,GAAGC,IAAI,CAACc,GAAG,CAAC,EAAE,EAAEnI,KAAK,CAAC;QAEvD,IAAIkI,MAAM,KAAK,IAAI,EAAE;UACnBrG,OAAO,CAACmB,OAAO,EAAE;UACjBM,aAAa,CAAC,CAAC,CAAC;UAChBL,aAAa,CAAC,CAAC,CAAC;QAClB,CAAC,MACI;UACHI,IAAI,EAAE;QACR;QAEAc,WAAW,CAAC9B,KAAK,GAAG,KAAK;QACzB;MACF;MAEAY,aAAa,CAACU,cAAc,CAACtB,KAAK,GAAG+E,QAAQ,CAAC;MAC9C9D,aAAa,CAACtE,OAAO,CAAC,CAAC,GAAGoI,QAAQ,GAAGpH,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;MAElD,IAAI6C,GAAG,CAACwF,OAAO,KAAK,IAAI,EAAE;QACxBlE,WAAW,CAAC9B,KAAK,GAAG,IAAI;MAC1B;IACF;IAEA,SAASuB,OAAOA,CAAA,EAAI;MAClBlC,iBAAiB,CAAC,KAAK,CAAC;MACxB8B,aAAa,CAAC,IAAI,CAAC;IACrB;IAEA,SAASyD,YAAYA,CAAEsB,IAAI,EAAE5B,GAAG,EAAE;MAChC9E,OAAO,CAAC2G,MAAM,CAAChJ,KAAK,CAACC,IAAI,EAAE8I,IAAI,EAAE5B,GAAG,CAAC;IACvC;IAEA,SAASD,WAAWA,CAAE6B,IAAI,EAAE5B,GAAG,EAAE;MAC/B,IAAI4B,IAAI,CAAClG,KAAK,KAAKsE,GAAG,EAAE;QACtB4B,IAAI,CAAClG,KAAK,GAAGsE,GAAG;MAClB;IACF;IAEA,SAASO,kBAAkBA,CAAE9G,aAAa,EAAEmC,IAAI,EAAE;MAChD0E,YAAY,CAAC,MAAM,EAAE7G,aAAa,KAAK,IAAI,GAAGZ,KAAK,CAACa,SAAS,GAAGkC,IAAI,CAAC;IACvE;IAEAV,OAAO,CAACsB,SAAS,CAAE3D,KAAK,CAACC,IAAI,CAAE,GAAGqE,QAAQ;IAC1CoD,kBAAkB,CAAC1H,KAAK,CAACY,aAAa,EAAEmC,IAAI,CAACF,KAAK,CAAC;IACnD4E,YAAY,CAAC,OAAO,EAAEpC,QAAQ,CAACxC,KAAK,CAAC;IACrC4E,YAAY,CAAC,QAAQ,EAAE3C,MAAM,CAACjC,KAAK,CAAC;IAEpC,IACE7C,KAAK,CAACgB,WAAW,KAAK,IAAI,IACvBhB,KAAK,CAACiD,UAAU,KAAK,IAAI,IACzBD,OAAO,CAACH,KAAK,KAAK,IAAI,IACtB7C,KAAK,CAAE,qBAAqB,CAAE,KAAK,KAAK,CAAC,EAC5C;MACA4B,IAAI,CAAC,mBAAmB,EAAE,IAAI,CAAC;IACjC;IAEAnD,SAAS,CAAC,MAAM;MACdmD,IAAI,CAAC,UAAU,EAAEyD,QAAQ,CAACxC,KAAK,CAAC;MAChCjB,IAAI,CAAC,WAAW,EAAEkB,MAAM,CAACD,KAAK,CAAC;MAE/BL,gBAAgB,GAAGxC,KAAK,CAACgB,WAAW,KAAK,IAAI;MAE7C,MAAMiI,EAAE,GAAGA,CAAA,KAAM;QACf,MAAMjB,MAAM,GAAGhF,OAAO,CAACH,KAAK,KAAK,IAAI,GAAGO,UAAU,GAAGa,UAAU;QAC/D+D,MAAM,CAAC,KAAK,EAAE,IAAI,CAAC;MACrB,CAAC;MAED,IAAI3F,OAAO,CAACO,UAAU,CAACC,KAAK,KAAK,CAAC,EAAE;QAClC;QACA;QACAlE,QAAQ,CAACsK,EAAE,CAAC;QACZ;MACF;MAEAvG,uBAAuB,GAAGlE,KAAK,CAAC6D,OAAO,CAACO,UAAU,EAAE,MAAM;QACxDF,uBAAuB,EAAE;QACzBA,uBAAuB,GAAG,KAAK,CAAC;QAEhC,IAAIM,OAAO,CAACH,KAAK,KAAK,KAAK,IAAI7C,KAAK,CAACgB,WAAW,KAAK,IAAI,IAAI2B,eAAe,CAACE,KAAK,KAAK,KAAK,EAAE;UAC5FwB,IAAI,CAAC,KAAK,CAAC;QACb,CAAC,MACI;UACH4E,EAAE,EAAE;QACN;MACF,CAAC,CAAC;IACJ,CAAC,CAAC;IAEFvK,eAAe,CAAC,MAAM;MACpBgE,uBAAuB,KAAK,KAAK,CAAC,IAAIA,uBAAuB,EAAE;MAE/D,IAAID,SAAS,KAAK,IAAI,EAAE;QACtB0F,YAAY,CAAC1F,SAAS,CAAC;QACvBA,SAAS,GAAG,IAAI;MAClB;MAEAO,OAAO,CAACH,KAAK,KAAK,IAAI,IAAIuB,OAAO,EAAE;MAEnC,IAAI/B,OAAO,CAACsB,SAAS,CAAE3D,KAAK,CAACC,IAAI,CAAE,KAAKqE,QAAQ,EAAE;QAChDjC,OAAO,CAACsB,SAAS,CAAE3D,KAAK,CAACC,IAAI,CAAE,GAAG,KAAK,CAAC;QACxCwH,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC;QACvBA,YAAY,CAAC,QAAQ,EAAE,CAAC,CAAC;QACzBA,YAAY,CAAC,OAAO,EAAE,KAAK,CAAC;MAC9B;IACF,CAAC,CAAC;IAEF,OAAO,MAAM;MACX,MAAMyB,KAAK,GAAG,EAAE;MAEhB,IAAIvG,eAAe,CAACE,KAAK,KAAK,IAAI,EAAE;QAClC7C,KAAK,CAACsB,WAAW,KAAK,KAAK,IAAI4H,KAAK,CAACC,IAAI,CACvC9K,cAAc,CACZD,CAAC,CAAC,KAAK,EAAE;UACPgL,GAAG,EAAE,MAAM;UACXC,KAAK,EAAG,0BAA0BrJ,KAAK,CAACC,IAAM,EAAC;UAC/C,aAAa,EAAE;QACjB,CAAC,CAAC,EACFwG,aAAa,CAAC5D,KAAK,CACpB,CACF;QAEDqG,KAAK,CAACC,IAAI,CACRzJ,IAAI,CACF,KAAK,EACL;UACEpB,GAAG,EAAE,UAAU;UACf+K,KAAK,EAAE/D,aAAa,CAACzC,KAAK;UAC1BsD,KAAK,EAAEZ,aAAa,CAAC1C,KAAK;UAC1B,aAAa,EAAE,MAAM;UACrByG,OAAO,EAAEzF;QACX,CAAC,EACD,KAAK,CAAC,EACN,UAAU,EACV7D,KAAK,CAACwB,eAAe,KAAK,IAAI,IAAIwB,OAAO,CAACH,KAAK,KAAK,IAAI,EACxD,MAAMkE,sBAAsB,CAAClE,KAAK,CACnC,CACF;MACH;MAEA,MAAMnC,IAAI,GAAGoC,MAAM,CAACD,KAAK,KAAK,IAAI,IAAIlB,KAAK,CAACjB,IAAI,KAAK,KAAK,CAAC;MAC3D,MAAM6I,OAAO,GAAG,CACdnL,CAAC,CAAC,KAAK,EAAE;QACP,GAAGyD,KAAK;QACRuH,GAAG,EAAE,EAAE,GAAG1I,IAAI;QAAE;QAChB2I,KAAK,EAAE,CACL9C,YAAY,CAAC1D,KAAK,EAClBhB,KAAK,CAACwH,KAAK;MAEf,CAAC,EAAE3I,IAAI,KAAK,IAAI,GACZiB,KAAK,CAACjB,IAAI,EAAE,GACZjB,KAAK,CAACkC,KAAK,CAACvB,OAAO,CAAC,CACvB,CACF;MAED,IAAIJ,KAAK,CAACmB,QAAQ,KAAK,IAAI,IAAI6B,OAAO,CAACH,KAAK,KAAK,IAAI,EAAE;QACrD0G,OAAO,CAACJ,IAAI,CACV/K,CAAC,CAAC,KAAK,EAAE;UACPiL,KAAK,EAAE;QACT,CAAC,CAAC,CACH;MACH;MAEAH,KAAK,CAACC,IAAI,CACRzJ,IAAI,CACF,OAAO,EACP;QAAEpB,GAAG,EAAE,SAAS;QAAE+K,KAAK,EAAE7C,OAAO,CAAC3D,KAAK;QAAEsD,KAAK,EAAEA,KAAK,CAACtD;MAAM,CAAC,EAC5D0G,OAAO,EACP,cAAc,EACdvJ,KAAK,CAACuB,YAAY,KAAK,IAAI,IAAIoB,eAAe,CAACE,KAAK,KAAK,IAAI,EAC7D,MAAMgE,qBAAqB,CAAChE,KAAK,CAClC,CACF;MAED,OAAOzE,CAAC,CAAC,KAAK,EAAE;QAAEiL,KAAK,EAAE;MAAqB,CAAC,EAAEH,KAAK,CAAC;IACzD,CAAC;EACH;AACF,CAAC,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}