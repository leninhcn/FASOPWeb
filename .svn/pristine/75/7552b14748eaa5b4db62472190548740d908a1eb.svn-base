{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, ref, computed, watch, onBeforeUnmount, onActivated, onDeactivated, getCurrentInstance, provide } from 'vue';\nimport QIcon from '../icon/QIcon.js';\nimport QResizeObserver from '../resize-observer/QResizeObserver.js';\nimport useTick from '../../composables/private/use-tick.js';\nimport useTimeout from '../../composables/private/use-timeout.js';\nimport { createComponent } from '../../utils/private/create.js';\nimport { hSlot } from '../../utils/private/render.js';\nimport { tabsKey } from '../../utils/private/symbols.js';\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js';\nfunction getIndicatorClass(color, top, vertical) {\n  const pos = vertical === true ? ['left', 'right'] : ['top', 'bottom'];\n  return `absolute-${top === true ? pos[0] : pos[1]}${color ? ` text-${color}` : ''}`;\n}\nconst alignValues = ['left', 'center', 'right', 'justify'];\nexport default createComponent({\n  name: 'QTabs',\n  props: {\n    modelValue: [Number, String],\n    align: {\n      type: String,\n      default: 'center',\n      validator: v => alignValues.includes(v)\n    },\n    breakpoint: {\n      type: [String, Number],\n      default: 600\n    },\n    vertical: Boolean,\n    shrink: Boolean,\n    stretch: Boolean,\n    activeClass: String,\n    activeColor: String,\n    activeBgColor: String,\n    indicatorColor: String,\n    leftIcon: String,\n    rightIcon: String,\n    outsideArrows: Boolean,\n    mobileArrows: Boolean,\n    switchIndicator: Boolean,\n    narrowIndicator: Boolean,\n    inlineLabel: Boolean,\n    noCaps: Boolean,\n    dense: Boolean,\n    contentClass: String,\n    'onUpdate:modelValue': [Function, Array]\n  },\n  setup(props, {\n    slots,\n    emit\n  }) {\n    const {\n      proxy\n    } = getCurrentInstance();\n    const {\n      $q\n    } = proxy;\n    const {\n      registerTick: registerScrollTick\n    } = useTick();\n    const {\n      registerTick: registerUpdateArrowsTick\n    } = useTick();\n    const {\n      registerTick: registerAnimateTick\n    } = useTick();\n    const {\n      registerTimeout: registerFocusTimeout,\n      removeTimeout: removeFocusTimeout\n    } = useTimeout();\n    const {\n      registerTimeout: registerScrollToTabTimeout,\n      removeTimeout: removeScrollToTabTimeout\n    } = useTimeout();\n    const rootRef = ref(null);\n    const contentRef = ref(null);\n    const currentModel = ref(props.modelValue);\n    const scrollable = ref(false);\n    const leftArrow = ref(true);\n    const rightArrow = ref(false);\n    const justify = ref(false);\n    const tabDataList = [];\n    const tabDataListLen = ref(0);\n    const hasFocus = ref(false);\n    let animateTimer = null,\n      scrollTimer = null,\n      unwatchRoute;\n    const tabProps = computed(() => ({\n      activeClass: props.activeClass,\n      activeColor: props.activeColor,\n      activeBgColor: props.activeBgColor,\n      indicatorClass: getIndicatorClass(props.indicatorColor, props.switchIndicator, props.vertical),\n      narrowIndicator: props.narrowIndicator,\n      inlineLabel: props.inlineLabel,\n      noCaps: props.noCaps\n    }));\n    const hasActiveTab = computed(() => {\n      const len = tabDataListLen.value;\n      const val = currentModel.value;\n      for (let i = 0; i < len; i++) {\n        if (tabDataList[i].name.value === val) {\n          return true;\n        }\n      }\n      return false;\n    });\n    const alignClass = computed(() => {\n      const align = scrollable.value === true ? 'left' : justify.value === true ? 'justify' : props.align;\n      return `q-tabs__content--align-${align}`;\n    });\n    const classes = computed(() => 'q-tabs row no-wrap items-center' + ` q-tabs--${scrollable.value === true ? '' : 'not-'}scrollable` + ` q-tabs--${props.vertical === true ? 'vertical' : 'horizontal'}` + ` q-tabs__arrows--${props.outsideArrows === true ? 'outside' : 'inside'}` + ` q-tabs--mobile-with${props.mobileArrows === true ? '' : 'out'}-arrows` + (props.dense === true ? ' q-tabs--dense' : '') + (props.shrink === true ? ' col-shrink' : '') + (props.stretch === true ? ' self-stretch' : ''));\n    const innerClass = computed(() => 'q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position ' + alignClass.value + (props.contentClass !== void 0 ? ` ${props.contentClass}` : ''));\n    const domProps = computed(() => props.vertical === true ? {\n      container: 'height',\n      content: 'offsetHeight',\n      scroll: 'scrollHeight'\n    } : {\n      container: 'width',\n      content: 'offsetWidth',\n      scroll: 'scrollWidth'\n    });\n    const isRTL = computed(() => props.vertical !== true && $q.lang.rtl === true);\n    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true);\n    watch(isRTL, updateArrows);\n    watch(() => props.modelValue, name => {\n      updateModel({\n        name,\n        setCurrent: true,\n        skipEmit: true\n      });\n    });\n    watch(() => props.outsideArrows, recalculateScroll);\n    function updateModel({\n      name,\n      setCurrent,\n      skipEmit\n    }) {\n      if (currentModel.value !== name) {\n        if (skipEmit !== true && props['onUpdate:modelValue'] !== void 0) {\n          emit('update:modelValue', name);\n        }\n        if (setCurrent === true || props['onUpdate:modelValue'] === void 0) {\n          animate(currentModel.value, name);\n          currentModel.value = name;\n        }\n      }\n    }\n    function recalculateScroll() {\n      registerScrollTick(() => {\n        updateContainer({\n          width: rootRef.value.offsetWidth,\n          height: rootRef.value.offsetHeight\n        });\n      });\n    }\n    function updateContainer(domSize) {\n      // it can be called faster than component being initialized\n      // so we need to protect against that case\n      // (one example of such case is the docs release notes page)\n      if (domProps.value === void 0 || contentRef.value === null) {\n        return;\n      }\n      const size = domSize[domProps.value.container],\n        scrollSize = Math.min(contentRef.value[domProps.value.scroll], Array.prototype.reduce.call(contentRef.value.children, (acc, el) => acc + (el[domProps.value.content] || 0), 0)),\n        scroll = size > 0 && scrollSize > size; // when there is no tab, in Chrome, size === 0 and scrollSize === 1\n\n      scrollable.value = scroll;\n\n      // Arrows need to be updated even if the scroll status was already true\n      scroll === true && registerUpdateArrowsTick(updateArrows);\n      justify.value = size < parseInt(props.breakpoint, 10);\n    }\n    function animate(oldName, newName) {\n      const oldTab = oldName !== void 0 && oldName !== null && oldName !== '' ? tabDataList.find(tab => tab.name.value === oldName) : null,\n        newTab = newName !== void 0 && newName !== null && newName !== '' ? tabDataList.find(tab => tab.name.value === newName) : null;\n      if (oldTab && newTab) {\n        const oldEl = oldTab.tabIndicatorRef.value,\n          newEl = newTab.tabIndicatorRef.value;\n        if (animateTimer !== null) {\n          clearTimeout(animateTimer);\n          animateTimer = null;\n        }\n        oldEl.style.transition = 'none';\n        oldEl.style.transform = 'none';\n        newEl.style.transition = 'none';\n        newEl.style.transform = 'none';\n        const oldPos = oldEl.getBoundingClientRect(),\n          newPos = newEl.getBoundingClientRect();\n        newEl.style.transform = props.vertical === true ? `translate3d(0,${oldPos.top - newPos.top}px,0) scale3d(1,${newPos.height ? oldPos.height / newPos.height : 1},1)` : `translate3d(${oldPos.left - newPos.left}px,0,0) scale3d(${newPos.width ? oldPos.width / newPos.width : 1},1,1)`;\n\n        // allow scope updates to kick in (QRouteTab needs more time)\n        registerAnimateTick(() => {\n          animateTimer = setTimeout(() => {\n            animateTimer = null;\n            newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)';\n            newEl.style.transform = 'none';\n          }, 70);\n        });\n      }\n      if (newTab && scrollable.value === true) {\n        scrollToTabEl(newTab.rootRef.value);\n      }\n    }\n    function scrollToTabEl(el) {\n      const {\n          left,\n          width,\n          top,\n          height\n        } = contentRef.value.getBoundingClientRect(),\n        newPos = el.getBoundingClientRect();\n      let offset = props.vertical === true ? newPos.top - top : newPos.left - left;\n      if (offset < 0) {\n        contentRef.value[props.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.floor(offset);\n        updateArrows();\n        return;\n      }\n      offset += props.vertical === true ? newPos.height - height : newPos.width - width;\n      if (offset > 0) {\n        contentRef.value[props.vertical === true ? 'scrollTop' : 'scrollLeft'] += Math.ceil(offset);\n        updateArrows();\n      }\n    }\n    function updateArrows() {\n      const content = contentRef.value;\n      if (content === null) {\n        return;\n      }\n      const rect = content.getBoundingClientRect(),\n        pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft);\n      if (isRTL.value === true) {\n        leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1;\n        rightArrow.value = pos > 0;\n      } else {\n        leftArrow.value = pos > 0;\n        rightArrow.value = props.vertical === true ? Math.ceil(pos + rect.height) < content.scrollHeight : Math.ceil(pos + rect.width) < content.scrollWidth;\n      }\n    }\n    function animScrollTo(value) {\n      scrollTimer !== null && clearInterval(scrollTimer);\n      scrollTimer = setInterval(() => {\n        if (scrollTowards(value) === true) {\n          stopAnimScroll();\n        }\n      }, 5);\n    }\n    function scrollToStart() {\n      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0);\n    }\n    function scrollToEnd() {\n      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER);\n    }\n    function stopAnimScroll() {\n      if (scrollTimer !== null) {\n        clearInterval(scrollTimer);\n        scrollTimer = null;\n      }\n    }\n    function onKbdNavigate(keyCode, fromEl) {\n      const tabs = Array.prototype.filter.call(contentRef.value.children, el => el === fromEl || el.matches && el.matches('.q-tab.q-focusable') === true);\n      const len = tabs.length;\n      if (len === 0) {\n        return;\n      }\n      if (keyCode === 36) {\n        // Home\n        scrollToTabEl(tabs[0]);\n        tabs[0].focus();\n        return true;\n      }\n      if (keyCode === 35) {\n        // End\n        scrollToTabEl(tabs[len - 1]);\n        tabs[len - 1].focus();\n        return true;\n      }\n      const dirPrev = keyCode === (props.vertical === true ? 38 /* ArrowUp */ : 37 /* ArrowLeft */);\n      const dirNext = keyCode === (props.vertical === true ? 40 /* ArrowDown */ : 39 /* ArrowRight */);\n\n      const dir = dirPrev === true ? -1 : dirNext === true ? 1 : void 0;\n      if (dir !== void 0) {\n        const rtlDir = isRTL.value === true ? -1 : 1;\n        const index = tabs.indexOf(fromEl) + dir * rtlDir;\n        if (index >= 0 && index < len) {\n          scrollToTabEl(tabs[index]);\n          tabs[index].focus({\n            preventScroll: true\n          });\n        }\n        return true;\n      }\n    }\n\n    // let's speed up execution of time-sensitive scrollTowards()\n    // with a computed variable by directly applying the minimal\n    // number of instructions on get/set functions\n    const posFn = computed(() => rtlPosCorrection.value === true ? {\n      get: content => Math.abs(content.scrollLeft),\n      set: (content, pos) => {\n        content.scrollLeft = -pos;\n      }\n    } : props.vertical === true ? {\n      get: content => content.scrollTop,\n      set: (content, pos) => {\n        content.scrollTop = pos;\n      }\n    } : {\n      get: content => content.scrollLeft,\n      set: (content, pos) => {\n        content.scrollLeft = pos;\n      }\n    });\n    function scrollTowards(value) {\n      const content = contentRef.value,\n        {\n          get,\n          set\n        } = posFn.value;\n      let done = false,\n        pos = get(content);\n      const direction = value < pos ? -1 : 1;\n      pos += direction * 5;\n      if (pos < 0) {\n        done = true;\n        pos = 0;\n      } else if (direction === -1 && pos <= value || direction === 1 && pos >= value) {\n        done = true;\n        pos = value;\n      }\n      set(content, pos);\n      updateArrows();\n      return done;\n    }\n    function hasQueryIncluded(targetQuery, matchingQuery) {\n      for (const key in targetQuery) {\n        if (targetQuery[key] !== matchingQuery[key]) {\n          return false;\n        }\n      }\n      return true;\n    }\n\n    // do not use directly; use verifyRouteModel() instead\n    function updateActiveRoute() {\n      let name = null,\n        bestScore = {\n          matchedLen: 0,\n          queryDiff: 9999,\n          hrefLen: 0\n        };\n      const list = tabDataList.filter(tab => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true);\n      const {\n        hash: currentHash,\n        query: currentQuery\n      } = proxy.$route;\n      const currentQueryLen = Object.keys(currentQuery).length;\n\n      // Vue Router does not keep account of hash & query when matching\n      // so we're doing this as well\n\n      for (const tab of list) {\n        const exact = tab.routeData.exact.value === true;\n        if (tab.routeData[exact === true ? 'linkIsExactActive' : 'linkIsActive'].value !== true) {\n          // it cannot match anything as it's not active nor exact-active\n          continue;\n        }\n        const {\n          hash,\n          query,\n          matched,\n          href\n        } = tab.routeData.resolvedLink.value;\n        const queryLen = Object.keys(query).length;\n        if (exact === true) {\n          if (hash !== currentHash) {\n            // it's set to exact but it doesn't matches the hash\n            continue;\n          }\n          if (queryLen !== currentQueryLen || hasQueryIncluded(currentQuery, query) === false) {\n            // it's set to exact but it doesn't matches the query\n            continue;\n          }\n\n          // yey, we found the perfect match (route + hash + query)\n          name = tab.name.value;\n          break;\n        }\n        if (hash !== '' && hash !== currentHash) {\n          // it has hash and it doesn't matches\n          continue;\n        }\n        if (queryLen !== 0 && hasQueryIncluded(query, currentQuery) === false) {\n          // it has query and it doesn't includes the current one\n          continue;\n        }\n        const newScore = {\n          matchedLen: matched.length,\n          queryDiff: currentQueryLen - queryLen,\n          hrefLen: href.length - hash.length\n        };\n        if (newScore.matchedLen > bestScore.matchedLen) {\n          // it matches more routes so it's more specific so we set it as current champion\n          name = tab.name.value;\n          bestScore = newScore;\n          continue;\n        } else if (newScore.matchedLen !== bestScore.matchedLen) {\n          // it matches less routes than the current champion so we discard it\n          continue;\n        }\n        if (newScore.queryDiff < bestScore.queryDiff) {\n          // query is closer to the current one so we set it as current champion\n          name = tab.name.value;\n          bestScore = newScore;\n        } else if (newScore.queryDiff !== bestScore.queryDiff) {\n          // it matches less routes than the current champion so we discard it\n          continue;\n        }\n        if (newScore.hrefLen > bestScore.hrefLen) {\n          // href is lengthier so it's more specific so we set it as current champion\n          name = tab.name.value;\n          bestScore = newScore;\n        }\n      }\n      if (name === null && tabDataList.some(tab => tab.routeData === void 0 && tab.name.value === currentModel.value) === true) {\n        // we shouldn't interfere if non-route tab is active\n        return;\n      }\n      updateModel({\n        name,\n        setCurrent: true\n      });\n    }\n    function onFocusin(e) {\n      removeFocusTimeout();\n      if (hasFocus.value !== true && rootRef.value !== null && e.target && typeof e.target.closest === 'function') {\n        const tab = e.target.closest('.q-tab');\n\n        // if the target is contained by a QTab/QRouteTab\n        // (it might be other elements focused, like additional QBtn)\n        if (tab && rootRef.value.contains(tab) === true) {\n          hasFocus.value = true;\n          scrollable.value === true && scrollToTabEl(tab);\n        }\n      }\n    }\n    function onFocusout() {\n      registerFocusTimeout(() => {\n        hasFocus.value = false;\n      }, 30);\n    }\n    function verifyRouteModel() {\n      if ($tabs.avoidRouteWatcher === false) {\n        registerScrollToTabTimeout(updateActiveRoute);\n      } else {\n        removeScrollToTabTimeout();\n      }\n    }\n    function watchRoute() {\n      if (unwatchRoute === void 0) {\n        const unwatch = watch(() => proxy.$route.fullPath, verifyRouteModel);\n        unwatchRoute = () => {\n          unwatch();\n          unwatchRoute = void 0;\n        };\n      }\n    }\n    function registerTab(tabData) {\n      tabDataList.push(tabData);\n      tabDataListLen.value++;\n      recalculateScroll();\n\n      // if it's a QTab or we don't have Vue Router\n      if (tabData.routeData === void 0 || proxy.$route === void 0) {\n        // we should position to the currently active tab (if any)\n        registerScrollToTabTimeout(() => {\n          if (scrollable.value === true) {\n            const value = currentModel.value;\n            const newTab = value !== void 0 && value !== null && value !== '' ? tabDataList.find(tab => tab.name.value === value) : null;\n            newTab && scrollToTabEl(newTab.rootRef.value);\n          }\n        });\n      }\n      // else if it's a QRouteTab with a valid link\n      else {\n        // start watching route\n        watchRoute();\n        if (tabData.routeData.hasRouterLink.value === true) {\n          verifyRouteModel();\n        }\n      }\n    }\n    function unregisterTab(tabData) {\n      tabDataList.splice(tabDataList.indexOf(tabData), 1);\n      tabDataListLen.value--;\n      recalculateScroll();\n      if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {\n        // unwatch route if we don't have any QRouteTabs left\n        if (tabDataList.every(tab => tab.routeData === void 0) === true) {\n          unwatchRoute();\n        }\n\n        // then update model\n        verifyRouteModel();\n      }\n    }\n    const $tabs = {\n      currentModel,\n      tabProps,\n      hasFocus,\n      hasActiveTab,\n      registerTab,\n      unregisterTab,\n      verifyRouteModel,\n      updateModel,\n      onKbdNavigate,\n      avoidRouteWatcher: false // false | string (uid)\n    };\n\n    provide(tabsKey, $tabs);\n    function cleanup() {\n      animateTimer !== null && clearTimeout(animateTimer);\n      stopAnimScroll();\n      unwatchRoute !== void 0 && unwatchRoute();\n    }\n    let hadRouteWatcher;\n    onBeforeUnmount(cleanup);\n    onDeactivated(() => {\n      hadRouteWatcher = unwatchRoute !== void 0;\n      cleanup();\n    });\n    onActivated(() => {\n      hadRouteWatcher === true && watchRoute();\n      recalculateScroll();\n    });\n    return () => {\n      return h('div', {\n        ref: rootRef,\n        class: classes.value,\n        role: 'tablist',\n        onFocusin,\n        onFocusout\n      }, [h(QResizeObserver, {\n        onResize: updateContainer\n      }), h('div', {\n        ref: contentRef,\n        class: innerClass.value,\n        onScroll: updateArrows\n      }, hSlot(slots.default)), h(QIcon, {\n        class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon' + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n        name: props.leftIcon || $q.iconSet.tabs[props.vertical === true ? 'up' : 'left'],\n        onMousedownPassive: scrollToStart,\n        onTouchstartPassive: scrollToStart,\n        onMouseupPassive: stopAnimScroll,\n        onMouseleavePassive: stopAnimScroll,\n        onTouchendPassive: stopAnimScroll\n      }), h(QIcon, {\n        class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon' + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n        name: props.rightIcon || $q.iconSet.tabs[props.vertical === true ? 'down' : 'right'],\n        onMousedownPassive: scrollToEnd,\n        onTouchstartPassive: scrollToEnd,\n        onMouseupPassive: stopAnimScroll,\n        onMouseleavePassive: stopAnimScroll,\n        onTouchendPassive: stopAnimScroll\n      })]);\n    };\n  }\n});","map":{"version":3,"names":["h","ref","computed","watch","onBeforeUnmount","onActivated","onDeactivated","getCurrentInstance","provide","QIcon","QResizeObserver","useTick","useTimeout","createComponent","hSlot","tabsKey","rtlHasScrollBug","getIndicatorClass","color","top","vertical","pos","alignValues","name","props","modelValue","Number","String","align","type","default","validator","v","includes","breakpoint","Boolean","shrink","stretch","activeClass","activeColor","activeBgColor","indicatorColor","leftIcon","rightIcon","outsideArrows","mobileArrows","switchIndicator","narrowIndicator","inlineLabel","noCaps","dense","contentClass","Function","Array","setup","slots","emit","proxy","$q","registerTick","registerScrollTick","registerUpdateArrowsTick","registerAnimateTick","registerTimeout","registerFocusTimeout","removeTimeout","removeFocusTimeout","registerScrollToTabTimeout","removeScrollToTabTimeout","rootRef","contentRef","currentModel","scrollable","leftArrow","rightArrow","justify","tabDataList","tabDataListLen","hasFocus","animateTimer","scrollTimer","unwatchRoute","tabProps","indicatorClass","hasActiveTab","len","value","val","i","alignClass","classes","innerClass","domProps","container","content","scroll","isRTL","lang","rtl","rtlPosCorrection","updateArrows","updateModel","setCurrent","skipEmit","recalculateScroll","animate","updateContainer","width","offsetWidth","height","offsetHeight","domSize","size","scrollSize","Math","min","prototype","reduce","call","children","acc","el","parseInt","oldName","newName","oldTab","find","tab","newTab","oldEl","tabIndicatorRef","newEl","clearTimeout","style","transition","transform","oldPos","getBoundingClientRect","newPos","left","setTimeout","scrollToTabEl","offset","floor","ceil","rect","scrollTop","abs","scrollLeft","scrollWidth","scrollHeight","animScrollTo","clearInterval","setInterval","scrollTowards","stopAnimScroll","scrollToStart","MAX_SAFE_INTEGER","scrollToEnd","onKbdNavigate","keyCode","fromEl","tabs","filter","matches","length","focus","dirPrev","dirNext","dir","rtlDir","index","indexOf","preventScroll","posFn","get","set","done","direction","hasQueryIncluded","targetQuery","matchingQuery","key","updateActiveRoute","bestScore","matchedLen","queryDiff","hrefLen","list","routeData","hasRouterLink","hash","currentHash","query","currentQuery","$route","currentQueryLen","Object","keys","exact","matched","href","resolvedLink","queryLen","newScore","some","onFocusin","e","target","closest","contains","onFocusout","verifyRouteModel","$tabs","avoidRouteWatcher","watchRoute","unwatch","fullPath","registerTab","tabData","push","unregisterTab","splice","every","cleanup","hadRouteWatcher","class","role","onResize","onScroll","iconSet","onMousedownPassive","onTouchstartPassive","onMouseupPassive","onMouseleavePassive","onTouchendPassive"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/components/tabs/QTabs.js"],"sourcesContent":["import { h, ref, computed, watch, onBeforeUnmount, onActivated, onDeactivated, getCurrentInstance, provide } from 'vue'\n\nimport QIcon from '../icon/QIcon.js'\nimport QResizeObserver from '../resize-observer/QResizeObserver.js'\n\nimport useTick from '../../composables/private/use-tick.js'\nimport useTimeout from '../../composables/private/use-timeout.js'\n\nimport { createComponent } from '../../utils/private/create.js'\nimport { hSlot } from '../../utils/private/render.js'\nimport { tabsKey } from '../../utils/private/symbols.js'\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js'\n\nfunction getIndicatorClass (color, top, vertical) {\n  const pos = vertical === true\n    ? [ 'left', 'right' ]\n    : [ 'top', 'bottom' ]\n\n  return `absolute-${ top === true ? pos[ 0 ] : pos[ 1 ] }${ color ? ` text-${ color }` : '' }`\n}\n\nconst alignValues = [ 'left', 'center', 'right', 'justify' ]\n\nexport default createComponent({\n  name: 'QTabs',\n\n  props: {\n    modelValue: [ Number, String ],\n\n    align: {\n      type: String,\n      default: 'center',\n      validator: v => alignValues.includes(v)\n    },\n    breakpoint: {\n      type: [ String, Number ],\n      default: 600\n    },\n\n    vertical: Boolean,\n    shrink: Boolean,\n    stretch: Boolean,\n\n    activeClass: String,\n    activeColor: String,\n    activeBgColor: String,\n    indicatorColor: String,\n    leftIcon: String,\n    rightIcon: String,\n\n    outsideArrows: Boolean,\n    mobileArrows: Boolean,\n\n    switchIndicator: Boolean,\n\n    narrowIndicator: Boolean,\n    inlineLabel: Boolean,\n    noCaps: Boolean,\n\n    dense: Boolean,\n\n    contentClass: String,\n\n    'onUpdate:modelValue': [ Function, Array ]\n  },\n\n  setup (props, { slots, emit }) {\n    const { proxy } = getCurrentInstance()\n    const { $q } = proxy\n\n    const { registerTick: registerScrollTick } = useTick()\n    const { registerTick: registerUpdateArrowsTick } = useTick()\n    const { registerTick: registerAnimateTick } = useTick()\n\n    const { registerTimeout: registerFocusTimeout, removeTimeout: removeFocusTimeout } = useTimeout()\n    const { registerTimeout: registerScrollToTabTimeout, removeTimeout: removeScrollToTabTimeout } = useTimeout()\n\n    const rootRef = ref(null)\n    const contentRef = ref(null)\n\n    const currentModel = ref(props.modelValue)\n    const scrollable = ref(false)\n    const leftArrow = ref(true)\n    const rightArrow = ref(false)\n    const justify = ref(false)\n\n    const tabDataList = []\n    const tabDataListLen = ref(0)\n    const hasFocus = ref(false)\n\n    let animateTimer = null, scrollTimer = null, unwatchRoute\n\n    const tabProps = computed(() => ({\n      activeClass: props.activeClass,\n      activeColor: props.activeColor,\n      activeBgColor: props.activeBgColor,\n      indicatorClass: getIndicatorClass(\n        props.indicatorColor,\n        props.switchIndicator,\n        props.vertical\n      ),\n      narrowIndicator: props.narrowIndicator,\n      inlineLabel: props.inlineLabel,\n      noCaps: props.noCaps\n    }))\n\n    const hasActiveTab = computed(() => {\n      const len = tabDataListLen.value\n      const val = currentModel.value\n\n      for (let i = 0; i < len; i++) {\n        if (tabDataList[ i ].name.value === val) {\n          return true\n        }\n      }\n\n      return false\n    })\n\n    const alignClass = computed(() => {\n      const align = scrollable.value === true\n        ? 'left'\n        : (justify.value === true ? 'justify' : props.align)\n\n      return `q-tabs__content--align-${ align }`\n    })\n\n    const classes = computed(() =>\n      'q-tabs row no-wrap items-center'\n      + ` q-tabs--${ scrollable.value === true ? '' : 'not-' }scrollable`\n      + ` q-tabs--${ props.vertical === true ? 'vertical' : 'horizontal' }`\n      + ` q-tabs__arrows--${ props.outsideArrows === true ? 'outside' : 'inside' }`\n      + ` q-tabs--mobile-with${ props.mobileArrows === true ? '' : 'out' }-arrows`\n      + (props.dense === true ? ' q-tabs--dense' : '')\n      + (props.shrink === true ? ' col-shrink' : '')\n      + (props.stretch === true ? ' self-stretch' : '')\n    )\n\n    const innerClass = computed(() =>\n      'q-tabs__content scroll--mobile row no-wrap items-center self-stretch hide-scrollbar relative-position '\n      + alignClass.value\n      + (props.contentClass !== void 0 ? ` ${ props.contentClass }` : '')\n    )\n\n    const domProps = computed(() => (\n      props.vertical === true\n        ? { container: 'height', content: 'offsetHeight', scroll: 'scrollHeight' }\n        : { container: 'width', content: 'offsetWidth', scroll: 'scrollWidth' }\n    ))\n\n    const isRTL = computed(() => props.vertical !== true && $q.lang.rtl === true)\n    const rtlPosCorrection = computed(() => rtlHasScrollBug === false && isRTL.value === true)\n\n    watch(isRTL, updateArrows)\n\n    watch(() => props.modelValue, name => {\n      updateModel({ name, setCurrent: true, skipEmit: true })\n    })\n\n    watch(() => props.outsideArrows, recalculateScroll)\n\n    function updateModel ({ name, setCurrent, skipEmit }) {\n      if (currentModel.value !== name) {\n        if (skipEmit !== true && props[ 'onUpdate:modelValue' ] !== void 0) {\n          emit('update:modelValue', name)\n        }\n\n        if (\n          setCurrent === true\n          || props[ 'onUpdate:modelValue' ] === void 0\n        ) {\n          animate(currentModel.value, name)\n          currentModel.value = name\n        }\n      }\n    }\n\n    function recalculateScroll () {\n      registerScrollTick(() => {\n        updateContainer({\n          width: rootRef.value.offsetWidth,\n          height: rootRef.value.offsetHeight\n        })\n      })\n    }\n\n    function updateContainer (domSize) {\n      // it can be called faster than component being initialized\n      // so we need to protect against that case\n      // (one example of such case is the docs release notes page)\n      if (domProps.value === void 0 || contentRef.value === null) { return }\n\n      const\n        size = domSize[ domProps.value.container ],\n        scrollSize = Math.min(\n          contentRef.value[ domProps.value.scroll ],\n          Array.prototype.reduce.call(\n            contentRef.value.children,\n            (acc, el) => acc + (el[ domProps.value.content ] || 0),\n            0\n          )\n        ),\n        scroll = size > 0 && scrollSize > size // when there is no tab, in Chrome, size === 0 and scrollSize === 1\n\n      scrollable.value = scroll\n\n      // Arrows need to be updated even if the scroll status was already true\n      scroll === true && registerUpdateArrowsTick(updateArrows)\n\n      justify.value = size < parseInt(props.breakpoint, 10)\n    }\n\n    function animate (oldName, newName) {\n      const\n        oldTab = oldName !== void 0 && oldName !== null && oldName !== ''\n          ? tabDataList.find(tab => tab.name.value === oldName)\n          : null,\n        newTab = newName !== void 0 && newName !== null && newName !== ''\n          ? tabDataList.find(tab => tab.name.value === newName)\n          : null\n\n      if (oldTab && newTab) {\n        const\n          oldEl = oldTab.tabIndicatorRef.value,\n          newEl = newTab.tabIndicatorRef.value\n\n        if (animateTimer !== null) {\n          clearTimeout(animateTimer)\n          animateTimer = null\n        }\n\n        oldEl.style.transition = 'none'\n        oldEl.style.transform = 'none'\n        newEl.style.transition = 'none'\n        newEl.style.transform = 'none'\n\n        const\n          oldPos = oldEl.getBoundingClientRect(),\n          newPos = newEl.getBoundingClientRect()\n\n        newEl.style.transform = props.vertical === true\n          ? `translate3d(0,${ oldPos.top - newPos.top }px,0) scale3d(1,${ newPos.height ? oldPos.height / newPos.height : 1 },1)`\n          : `translate3d(${ oldPos.left - newPos.left }px,0,0) scale3d(${ newPos.width ? oldPos.width / newPos.width : 1 },1,1)`\n\n        // allow scope updates to kick in (QRouteTab needs more time)\n        registerAnimateTick(() => {\n          animateTimer = setTimeout(() => {\n            animateTimer = null\n            newEl.style.transition = 'transform .25s cubic-bezier(.4, 0, .2, 1)'\n            newEl.style.transform = 'none'\n          }, 70)\n        })\n      }\n\n      if (newTab && scrollable.value === true) {\n        scrollToTabEl(newTab.rootRef.value)\n      }\n    }\n\n    function scrollToTabEl (el) {\n      const\n        { left, width, top, height } = contentRef.value.getBoundingClientRect(),\n        newPos = el.getBoundingClientRect()\n\n      let offset = props.vertical === true ? newPos.top - top : newPos.left - left\n\n      if (offset < 0) {\n        contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.floor(offset)\n        updateArrows()\n        return\n      }\n\n      offset += props.vertical === true ? newPos.height - height : newPos.width - width\n      if (offset > 0) {\n        contentRef.value[ props.vertical === true ? 'scrollTop' : 'scrollLeft' ] += Math.ceil(offset)\n        updateArrows()\n      }\n    }\n\n    function updateArrows () {\n      const content = contentRef.value\n      if (content === null) { return }\n\n      const\n        rect = content.getBoundingClientRect(),\n        pos = props.vertical === true ? content.scrollTop : Math.abs(content.scrollLeft)\n\n      if (isRTL.value === true) {\n        leftArrow.value = Math.ceil(pos + rect.width) < content.scrollWidth - 1\n        rightArrow.value = pos > 0\n      }\n      else {\n        leftArrow.value = pos > 0\n        rightArrow.value = props.vertical === true\n          ? Math.ceil(pos + rect.height) < content.scrollHeight\n          : Math.ceil(pos + rect.width) < content.scrollWidth\n      }\n    }\n\n    function animScrollTo (value) {\n      scrollTimer !== null && clearInterval(scrollTimer)\n      scrollTimer = setInterval(() => {\n        if (scrollTowards(value) === true) {\n          stopAnimScroll()\n        }\n      }, 5)\n    }\n\n    function scrollToStart () {\n      animScrollTo(rtlPosCorrection.value === true ? Number.MAX_SAFE_INTEGER : 0)\n    }\n\n    function scrollToEnd () {\n      animScrollTo(rtlPosCorrection.value === true ? 0 : Number.MAX_SAFE_INTEGER)\n    }\n\n    function stopAnimScroll () {\n      if (scrollTimer !== null) {\n        clearInterval(scrollTimer)\n        scrollTimer = null\n      }\n    }\n\n    function onKbdNavigate (keyCode, fromEl) {\n      const tabs = Array.prototype.filter.call(\n        contentRef.value.children,\n        el => el === fromEl || (el.matches && el.matches('.q-tab.q-focusable') === true)\n      )\n\n      const len = tabs.length\n      if (len === 0) { return }\n\n      if (keyCode === 36) { // Home\n        scrollToTabEl(tabs[ 0 ])\n        tabs[ 0 ].focus()\n        return true\n      }\n      if (keyCode === 35) { // End\n        scrollToTabEl(tabs[ len - 1 ])\n        tabs[ len - 1 ].focus()\n        return true\n      }\n\n      const dirPrev = keyCode === (props.vertical === true ? 38 /* ArrowUp */ : 37 /* ArrowLeft */)\n      const dirNext = keyCode === (props.vertical === true ? 40 /* ArrowDown */ : 39 /* ArrowRight */)\n\n      const dir = dirPrev === true ? -1 : (dirNext === true ? 1 : void 0)\n\n      if (dir !== void 0) {\n        const rtlDir = isRTL.value === true ? -1 : 1\n        const index = tabs.indexOf(fromEl) + dir * rtlDir\n\n        if (index >= 0 && index < len) {\n          scrollToTabEl(tabs[ index ])\n          tabs[ index ].focus({ preventScroll: true })\n        }\n\n        return true\n      }\n    }\n\n    // let's speed up execution of time-sensitive scrollTowards()\n    // with a computed variable by directly applying the minimal\n    // number of instructions on get/set functions\n    const posFn = computed(() => (\n      rtlPosCorrection.value === true\n        ? { get: content => Math.abs(content.scrollLeft), set: (content, pos) => { content.scrollLeft = -pos } }\n        : (\n            props.vertical === true\n              ? { get: content => content.scrollTop, set: (content, pos) => { content.scrollTop = pos } }\n              : { get: content => content.scrollLeft, set: (content, pos) => { content.scrollLeft = pos } }\n          )\n    ))\n\n    function scrollTowards (value) {\n      const\n        content = contentRef.value,\n        { get, set } = posFn.value\n\n      let\n        done = false,\n        pos = get(content)\n\n      const direction = value < pos ? -1 : 1\n\n      pos += direction * 5\n\n      if (pos < 0) {\n        done = true\n        pos = 0\n      }\n      else if (\n        (direction === -1 && pos <= value)\n        || (direction === 1 && pos >= value)\n      ) {\n        done = true\n        pos = value\n      }\n\n      set(content, pos)\n      updateArrows()\n\n      return done\n    }\n\n    function hasQueryIncluded (targetQuery, matchingQuery) {\n      for (const key in targetQuery) {\n        if (targetQuery[ key ] !== matchingQuery[ key ]) {\n          return false\n        }\n      }\n\n      return true\n    }\n\n    // do not use directly; use verifyRouteModel() instead\n    function updateActiveRoute () {\n      let name = null, bestScore = { matchedLen: 0, queryDiff: 9999, hrefLen: 0 }\n\n      const list = tabDataList.filter(tab => tab.routeData !== void 0 && tab.routeData.hasRouterLink.value === true)\n      const { hash: currentHash, query: currentQuery } = proxy.$route\n      const currentQueryLen = Object.keys(currentQuery).length\n\n      // Vue Router does not keep account of hash & query when matching\n      // so we're doing this as well\n\n      for (const tab of list) {\n        const exact = tab.routeData.exact.value === true\n\n        if (tab.routeData[ exact === true ? 'linkIsExactActive' : 'linkIsActive' ].value !== true) {\n          // it cannot match anything as it's not active nor exact-active\n          continue\n        }\n\n        const { hash, query, matched, href } = tab.routeData.resolvedLink.value\n        const queryLen = Object.keys(query).length\n\n        if (exact === true) {\n          if (hash !== currentHash) {\n            // it's set to exact but it doesn't matches the hash\n            continue\n          }\n\n          if (\n            queryLen !== currentQueryLen\n            || hasQueryIncluded(currentQuery, query) === false\n          ) {\n            // it's set to exact but it doesn't matches the query\n            continue\n          }\n\n          // yey, we found the perfect match (route + hash + query)\n          name = tab.name.value\n          break\n        }\n\n        if (hash !== '' && hash !== currentHash) {\n          // it has hash and it doesn't matches\n          continue\n        }\n\n        if (\n          queryLen !== 0\n          && hasQueryIncluded(query, currentQuery) === false\n        ) {\n          // it has query and it doesn't includes the current one\n          continue\n        }\n\n        const newScore = {\n          matchedLen: matched.length,\n          queryDiff: currentQueryLen - queryLen,\n          hrefLen: href.length - hash.length\n        }\n\n        if (newScore.matchedLen > bestScore.matchedLen) {\n          // it matches more routes so it's more specific so we set it as current champion\n          name = tab.name.value\n          bestScore = newScore\n          continue\n        }\n        else if (newScore.matchedLen !== bestScore.matchedLen) {\n          // it matches less routes than the current champion so we discard it\n          continue\n        }\n\n        if (newScore.queryDiff < bestScore.queryDiff) {\n          // query is closer to the current one so we set it as current champion\n          name = tab.name.value\n          bestScore = newScore\n        }\n        else if (newScore.queryDiff !== bestScore.queryDiff) {\n          // it matches less routes than the current champion so we discard it\n          continue\n        }\n\n        if (newScore.hrefLen > bestScore.hrefLen) {\n          // href is lengthier so it's more specific so we set it as current champion\n          name = tab.name.value\n          bestScore = newScore\n        }\n      }\n\n      if (\n        name === null\n        && tabDataList.some(tab => tab.routeData === void 0 && tab.name.value === currentModel.value) === true\n      ) {\n        // we shouldn't interfere if non-route tab is active\n        return\n      }\n\n      updateModel({ name, setCurrent: true })\n    }\n\n    function onFocusin (e) {\n      removeFocusTimeout()\n\n      if (\n        hasFocus.value !== true\n        && rootRef.value !== null\n        && e.target\n        && typeof e.target.closest === 'function'\n      ) {\n        const tab = e.target.closest('.q-tab')\n\n        // if the target is contained by a QTab/QRouteTab\n        // (it might be other elements focused, like additional QBtn)\n        if (tab && rootRef.value.contains(tab) === true) {\n          hasFocus.value = true\n          scrollable.value === true && scrollToTabEl(tab)\n        }\n      }\n    }\n\n    function onFocusout () {\n      registerFocusTimeout(() => { hasFocus.value = false }, 30)\n    }\n\n    function verifyRouteModel () {\n      if ($tabs.avoidRouteWatcher === false) {\n        registerScrollToTabTimeout(updateActiveRoute)\n      }\n      else {\n        removeScrollToTabTimeout()\n      }\n    }\n\n    function watchRoute () {\n      if (unwatchRoute === void 0) {\n        const unwatch = watch(() => proxy.$route.fullPath, verifyRouteModel)\n        unwatchRoute = () => {\n          unwatch()\n          unwatchRoute = void 0\n        }\n      }\n    }\n\n    function registerTab (tabData) {\n      tabDataList.push(tabData)\n      tabDataListLen.value++\n\n      recalculateScroll()\n\n      // if it's a QTab or we don't have Vue Router\n      if (tabData.routeData === void 0 || proxy.$route === void 0) {\n        // we should position to the currently active tab (if any)\n        registerScrollToTabTimeout(() => {\n          if (scrollable.value === true) {\n            const value = currentModel.value\n            const newTab = value !== void 0 && value !== null && value !== ''\n              ? tabDataList.find(tab => tab.name.value === value)\n              : null\n\n            newTab && scrollToTabEl(newTab.rootRef.value)\n          }\n        })\n      }\n      // else if it's a QRouteTab with a valid link\n      else {\n        // start watching route\n        watchRoute()\n\n        if (tabData.routeData.hasRouterLink.value === true) {\n          verifyRouteModel()\n        }\n      }\n    }\n\n    function unregisterTab (tabData) {\n      tabDataList.splice(tabDataList.indexOf(tabData), 1)\n      tabDataListLen.value--\n\n      recalculateScroll()\n\n      if (unwatchRoute !== void 0 && tabData.routeData !== void 0) {\n        // unwatch route if we don't have any QRouteTabs left\n        if (tabDataList.every(tab => tab.routeData === void 0) === true) {\n          unwatchRoute()\n        }\n\n        // then update model\n        verifyRouteModel()\n      }\n    }\n\n    const $tabs = {\n      currentModel,\n      tabProps,\n      hasFocus,\n      hasActiveTab,\n\n      registerTab,\n      unregisterTab,\n\n      verifyRouteModel,\n      updateModel,\n      onKbdNavigate,\n\n      avoidRouteWatcher: false // false | string (uid)\n    }\n\n    provide(tabsKey, $tabs)\n\n    function cleanup () {\n      animateTimer !== null && clearTimeout(animateTimer)\n      stopAnimScroll()\n      unwatchRoute !== void 0 && unwatchRoute()\n    }\n\n    let hadRouteWatcher\n\n    onBeforeUnmount(cleanup)\n\n    onDeactivated(() => {\n      hadRouteWatcher = unwatchRoute !== void 0\n      cleanup()\n    })\n\n    onActivated(() => {\n      hadRouteWatcher === true && watchRoute()\n      recalculateScroll()\n    })\n\n    return () => {\n      return h('div', {\n        ref: rootRef,\n        class: classes.value,\n        role: 'tablist',\n        onFocusin,\n        onFocusout\n      }, [\n        h(QResizeObserver, { onResize: updateContainer }),\n\n        h('div', {\n          ref: contentRef,\n          class: innerClass.value,\n          onScroll: updateArrows\n        }, hSlot(slots.default)),\n\n        h(QIcon, {\n          class: 'q-tabs__arrow q-tabs__arrow--left absolute q-tab__icon'\n            + (leftArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n          name: props.leftIcon || $q.iconSet.tabs[ props.vertical === true ? 'up' : 'left' ],\n          onMousedownPassive: scrollToStart,\n          onTouchstartPassive: scrollToStart,\n          onMouseupPassive: stopAnimScroll,\n          onMouseleavePassive: stopAnimScroll,\n          onTouchendPassive: stopAnimScroll\n        }),\n\n        h(QIcon, {\n          class: 'q-tabs__arrow q-tabs__arrow--right absolute q-tab__icon'\n            + (rightArrow.value === true ? '' : ' q-tabs__arrow--faded'),\n          name: props.rightIcon || $q.iconSet.tabs[ props.vertical === true ? 'down' : 'right' ],\n          onMousedownPassive: scrollToEnd,\n          onTouchstartPassive: scrollToEnd,\n          onMouseupPassive: stopAnimScroll,\n          onMouseleavePassive: stopAnimScroll,\n          onTouchendPassive: stopAnimScroll\n        })\n      ])\n    }\n  }\n})\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}