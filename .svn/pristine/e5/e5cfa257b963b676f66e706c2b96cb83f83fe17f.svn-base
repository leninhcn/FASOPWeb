{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { h, ref, computed, watch, onActivated, onDeactivated, onBeforeMount, onBeforeUnmount, nextTick, getCurrentInstance } from 'vue';\nimport debounce from '../../utils/debounce.js';\nimport { noop } from '../../utils/event.js';\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js';\nconst aggBucketSize = 1000;\nconst scrollToEdges = ['start', 'center', 'end', 'start-force', 'center-force', 'end-force'];\nconst filterProto = Array.prototype.filter;\nconst setOverflowAnchor = __QUASAR_SSR__ || window.getComputedStyle(document.body).overflowAnchor === void 0 ? noop : function (contentEl, index) {\n  if (contentEl === null) {\n    return;\n  }\n  if (contentEl._qOverflowAnimationFrame !== void 0) {\n    cancelAnimationFrame(contentEl._qOverflowAnimationFrame);\n  }\n  contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {\n    if (contentEl === null) {\n      return;\n    }\n    contentEl._qOverflowAnimationFrame = void 0;\n    const children = contentEl.children || [];\n    filterProto.call(children, el => el.dataset && el.dataset.qVsAnchor !== void 0).forEach(el => {\n      delete el.dataset.qVsAnchor;\n    });\n    const el = children[index];\n    if (el && el.dataset) {\n      el.dataset.qVsAnchor = '';\n    }\n  });\n};\nfunction sumFn(acc, h) {\n  return acc + h;\n}\nfunction getScrollDetails(parent, child, beforeRef, afterRef, horizontal, rtl, stickyStart, stickyEnd) {\n  const parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,\n    propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',\n    details = {\n      scrollStart: 0,\n      scrollViewSize: -stickyStart - stickyEnd,\n      scrollMaxSize: 0,\n      offsetStart: -stickyStart,\n      offsetEnd: -stickyEnd\n    };\n  if (horizontal === true) {\n    if (parent === window) {\n      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0;\n      details.scrollViewSize += document.documentElement.clientWidth;\n    } else {\n      details.scrollStart = parentCalc.scrollLeft;\n      details.scrollViewSize += parentCalc.clientWidth;\n    }\n    details.scrollMaxSize = parentCalc.scrollWidth;\n    if (rtl === true) {\n      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart;\n    }\n  } else {\n    if (parent === window) {\n      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0;\n      details.scrollViewSize += document.documentElement.clientHeight;\n    } else {\n      details.scrollStart = parentCalc.scrollTop;\n      details.scrollViewSize += parentCalc.clientHeight;\n    }\n    details.scrollMaxSize = parentCalc.scrollHeight;\n  }\n  if (beforeRef !== null) {\n    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetStart += el[propElSize];\n      }\n    }\n  }\n  if (afterRef !== null) {\n    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetEnd += el[propElSize];\n      }\n    }\n  }\n  if (child !== parent) {\n    const parentRect = parentCalc.getBoundingClientRect(),\n      childRect = child.getBoundingClientRect();\n    if (horizontal === true) {\n      details.offsetStart += childRect.left - parentRect.left;\n      details.offsetEnd -= childRect.width;\n    } else {\n      details.offsetStart += childRect.top - parentRect.top;\n      details.offsetEnd -= childRect.height;\n    }\n    if (parent !== window) {\n      details.offsetStart += details.scrollStart;\n    }\n    details.offsetEnd += details.scrollMaxSize - details.offsetStart;\n  }\n  return details;\n}\nfunction setScroll(parent, scroll, horizontal, rtl) {\n  if (scroll === 'end') {\n    scroll = (parent === window ? document.body : parent)[horizontal === true ? 'scrollWidth' : 'scrollHeight'];\n  }\n  if (parent === window) {\n    if (horizontal === true) {\n      if (rtl === true) {\n        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll;\n      }\n      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0);\n    } else {\n      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll);\n    }\n  } else if (horizontal === true) {\n    if (rtl === true) {\n      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll;\n    }\n    parent.scrollLeft = scroll;\n  } else {\n    parent.scrollTop = scroll;\n  }\n}\nfunction sumSize(sizeAgg, size, from, to) {\n  if (from >= to) {\n    return 0;\n  }\n  const lastTo = size.length,\n    fromAgg = Math.floor(from / aggBucketSize),\n    toAgg = Math.floor((to - 1) / aggBucketSize) + 1;\n  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0);\n  if (from % aggBucketSize !== 0) {\n    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0);\n  }\n  if (to % aggBucketSize !== 0 && to !== lastTo) {\n    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0);\n  }\n  return total;\n}\nconst commonVirtScrollProps = {\n  virtualScrollSliceSize: {\n    type: [Number, String],\n    default: null\n  },\n  virtualScrollSliceRatioBefore: {\n    type: [Number, String],\n    default: 1\n  },\n  virtualScrollSliceRatioAfter: {\n    type: [Number, String],\n    default: 1\n  },\n  virtualScrollItemSize: {\n    type: [Number, String],\n    default: 24\n  },\n  virtualScrollStickySizeStart: {\n    type: [Number, String],\n    default: 0\n  },\n  virtualScrollStickySizeEnd: {\n    type: [Number, String],\n    default: 0\n  },\n  tableColspan: [Number, String]\n};\nexport const commonVirtPropsList = Object.keys(commonVirtScrollProps);\nexport const useVirtualScrollProps = {\n  virtualScrollHorizontal: Boolean,\n  onVirtualScroll: Function,\n  ...commonVirtScrollProps\n};\nexport function useVirtualScroll({\n  virtualScrollLength,\n  getVirtualScrollTarget,\n  getVirtualScrollEl,\n  virtualScrollItemSizeComputed // optional\n}) {\n  const vm = getCurrentInstance();\n  const {\n    props,\n    emit,\n    proxy\n  } = vm;\n  const {\n    $q\n  } = proxy;\n  let prevScrollStart,\n    prevToIndex,\n    localScrollViewSize,\n    virtualScrollSizesAgg = [],\n    virtualScrollSizes;\n  const virtualScrollPaddingBefore = ref(0);\n  const virtualScrollPaddingAfter = ref(0);\n  const virtualScrollSliceSizeComputed = ref({});\n  const beforeRef = ref(null);\n  const afterRef = ref(null);\n  const contentRef = ref(null);\n  const virtualScrollSliceRange = ref({\n    from: 0,\n    to: 0\n  });\n  const colspanAttr = computed(() => props.tableColspan !== void 0 ? props.tableColspan : 100);\n  if (virtualScrollItemSizeComputed === void 0) {\n    virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize);\n  }\n  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ';' + props.virtualScrollHorizontal);\n  const needsSliceRecalc = computed(() => needsReset.value + ';' + props.virtualScrollSliceRatioBefore + ';' + props.virtualScrollSliceRatioAfter);\n  watch(needsSliceRecalc, () => {\n    setVirtualScrollSize();\n  });\n  watch(needsReset, reset);\n  function reset() {\n    localResetVirtualScroll(prevToIndex, true);\n  }\n  function refresh(toIndex) {\n    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex);\n  }\n  function scrollTo(toIndex, edge) {\n    const scrollEl = getVirtualScrollTarget();\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return;\n    }\n    const scrollDetails = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd);\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);\n    setVirtualScrollSliceRange(scrollEl, scrollDetails, Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)), 0, scrollToEdges.indexOf(edge) > -1 ? edge : prevToIndex > -1 && toIndex > prevToIndex ? 'end' : 'start');\n  }\n  function localOnVirtualScrollEvt() {\n    const scrollEl = getVirtualScrollTarget();\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return;\n    }\n    const scrollDetails = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd),\n      listLastIndex = virtualScrollLength.value - 1,\n      listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value;\n    if (prevScrollStart === scrollDetails.scrollStart) {\n      return;\n    }\n    if (scrollDetails.scrollMaxSize <= 0) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0);\n      return;\n    }\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize);\n    updateVirtualScrollSizes(virtualScrollSliceRange.value.from);\n    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd) - Math.min(virtualScrollSizes[listLastIndex], scrollDetails.scrollViewSize / 2));\n    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, listLastIndex, scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0));\n      return;\n    }\n    let toIndex = 0,\n      listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,\n      offset = listOffset;\n    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {\n      listOffset -= virtualScrollPaddingBefore.value;\n      toIndex = virtualScrollSliceRange.value.from;\n      offset = listOffset;\n    } else {\n      for (let j = 0; listOffset >= virtualScrollSizesAgg[j] && toIndex < listLastIndex; j++) {\n        listOffset -= virtualScrollSizesAgg[j];\n        toIndex += aggBucketSize;\n      }\n    }\n    while (listOffset > 0 && toIndex < listLastIndex) {\n      listOffset -= virtualScrollSizes[toIndex];\n      if (listOffset > -scrollDetails.scrollViewSize) {\n        toIndex++;\n        offset = listOffset;\n      } else {\n        offset = virtualScrollSizes[toIndex] + listOffset;\n      }\n    }\n    setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset);\n  }\n  function setVirtualScrollSliceRange(scrollEl, scrollDetails, toIndex, offset, align) {\n    const alignForce = typeof align === 'string' && align.indexOf('-force') > -1;\n    const alignEnd = alignForce === true ? align.replace('-force', '') : align;\n    const alignRange = alignEnd !== void 0 ? alignEnd : 'start';\n    let from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[alignRange]),\n      to = from + virtualScrollSliceSizeComputed.value.total;\n    if (to > virtualScrollLength.value) {\n      to = virtualScrollLength.value;\n      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total);\n    }\n    prevScrollStart = scrollDetails.scrollStart;\n    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to;\n    if (rangeChanged === false && alignEnd === void 0) {\n      emitScroll(toIndex);\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    const contentEl = contentRef.value;\n    if (rangeChanged === true && contentEl !== null && contentEl !== activeElement && contentEl.contains(activeElement) === true) {\n      contentEl.addEventListener('focusout', onBlurRefocusFn);\n      setTimeout(() => {\n        contentEl !== null && contentEl.removeEventListener('focusout', onBlurRefocusFn);\n      });\n    }\n    setOverflowAnchor(contentEl, toIndex - from);\n    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0;\n    if (rangeChanged === true) {\n      // vue key matching algorithm works only if\n      // the array of VNodes changes on only one of the ends\n      // so we first change one end and then the other\n\n      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to ? virtualScrollSliceRange.value.to : to;\n      virtualScrollSliceRange.value = {\n        from,\n        to: tempTo\n      };\n      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from);\n      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);\n      requestAnimationFrame(() => {\n        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {\n          virtualScrollSliceRange.value = {\n            from: virtualScrollSliceRange.value.from,\n            to\n          };\n          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value);\n        }\n      });\n    }\n    requestAnimationFrame(() => {\n      // if the scroll was changed give up\n      // (another call to setVirtualScrollSliceRange before animation frame)\n      if (prevScrollStart !== scrollDetails.scrollStart) {\n        return;\n      }\n      if (rangeChanged === true) {\n        updateVirtualScrollSizes(from);\n      }\n      const sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),\n        posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value,\n        posEnd = posStart + virtualScrollSizes[toIndex];\n      let scrollPosition = posStart + offset;\n      if (alignEnd !== void 0) {\n        const sizeDiff = sizeAfter - sizeBefore;\n        const scrollStart = scrollDetails.scrollStart + sizeDiff;\n        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize ? scrollStart : alignEnd === 'end' ? posEnd - scrollDetails.scrollViewSize : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[toIndex]) / 2));\n      }\n      prevScrollStart = scrollPosition;\n      setScroll(scrollEl, scrollPosition, props.virtualScrollHorizontal, $q.lang.rtl);\n      emitScroll(toIndex);\n    });\n  }\n  function updateVirtualScrollSizes(from) {\n    const contentEl = contentRef.value;\n    if (contentEl) {\n      const children = filterProto.call(contentEl.children, el => el.classList && el.classList.contains('q-virtual-scroll--skip') === false),\n        childrenLength = children.length,\n        sizeFn = props.virtualScrollHorizontal === true ? el => el.getBoundingClientRect().width : el => el.offsetHeight;\n      let index = from,\n        size,\n        diff;\n      for (let i = 0; i < childrenLength;) {\n        size = sizeFn(children[i]);\n        i++;\n        while (i < childrenLength && children[i].classList.contains('q-virtual-scroll--with-prev') === true) {\n          size += sizeFn(children[i]);\n          i++;\n        }\n        diff = size - virtualScrollSizes[index];\n        if (diff !== 0) {\n          virtualScrollSizes[index] += diff;\n          virtualScrollSizesAgg[Math.floor(index / aggBucketSize)] += diff;\n        }\n        index++;\n      }\n    }\n  }\n  function onBlurRefocusFn() {\n    contentRef.value !== null && contentRef.value !== void 0 && contentRef.value.focus();\n  }\n  function localResetVirtualScroll(toIndex, fullReset) {\n    const defaultSize = 1 * virtualScrollItemSizeComputed.value;\n    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {\n      virtualScrollSizes = [];\n    }\n    const oldVirtualScrollSizesLength = virtualScrollSizes.length;\n    virtualScrollSizes.length = virtualScrollLength.value;\n    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {\n      virtualScrollSizes[i] = defaultSize;\n    }\n    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize);\n    virtualScrollSizesAgg = [];\n    for (let j = 0; j <= jMax; j++) {\n      let size = 0;\n      const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value);\n      for (let i = j * aggBucketSize; i < iMax; i++) {\n        size += virtualScrollSizes[i];\n      }\n      virtualScrollSizesAgg.push(size);\n    }\n    prevToIndex = -1;\n    prevScrollStart = void 0;\n    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from);\n    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value);\n    if (toIndex >= 0) {\n      updateVirtualScrollSizes(virtualScrollSliceRange.value.from);\n      nextTick(() => {\n        scrollTo(toIndex);\n      });\n    } else {\n      onVirtualScrollEvt();\n    }\n  }\n  function setVirtualScrollSize(scrollViewSize) {\n    if (scrollViewSize === void 0 && typeof window !== 'undefined') {\n      const scrollEl = getVirtualScrollTarget();\n      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n        scrollViewSize = getScrollDetails(scrollEl, getVirtualScrollEl(), beforeRef.value, afterRef.value, props.virtualScrollHorizontal, $q.lang.rtl, props.virtualScrollStickySizeStart, props.virtualScrollStickySizeEnd).scrollViewSize;\n      }\n    }\n    localScrollViewSize = scrollViewSize;\n    const virtualScrollSliceRatioBefore = parseFloat(props.virtualScrollSliceRatioBefore) || 0;\n    const virtualScrollSliceRatioAfter = parseFloat(props.virtualScrollSliceRatioAfter) || 0;\n    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter;\n    const view = scrollViewSize === void 0 || scrollViewSize <= 0 ? 1 : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value);\n    const baseSize = Math.max(1, view, Math.ceil((props.virtualScrollSliceSize > 0 ? props.virtualScrollSliceSize : 10) / multiplier));\n    virtualScrollSliceSizeComputed.value = {\n      total: Math.ceil(baseSize * multiplier),\n      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),\n      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),\n      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),\n      view\n    };\n  }\n  function padVirtualScroll(tag, content) {\n    const paddingSize = props.virtualScrollHorizontal === true ? 'width' : 'height';\n    const style = {\n      ['--q-virtual-scroll-item-' + paddingSize]: virtualScrollItemSizeComputed.value + 'px'\n    };\n    return [tag === 'tbody' ? h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'before',\n      ref: beforeRef\n    }, [h('tr', [h('td', {\n      style: {\n        [paddingSize]: `${virtualScrollPaddingBefore.value}px`,\n        ...style\n      },\n      colspan: colspanAttr.value\n    })])]) : h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'before',\n      ref: beforeRef,\n      style: {\n        [paddingSize]: `${virtualScrollPaddingBefore.value}px`,\n        ...style\n      }\n    }), h(tag, {\n      class: 'q-virtual-scroll__content',\n      key: 'content',\n      ref: contentRef,\n      tabindex: -1\n    }, content.flat()), tag === 'tbody' ? h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'after',\n      ref: afterRef\n    }, [h('tr', [h('td', {\n      style: {\n        [paddingSize]: `${virtualScrollPaddingAfter.value}px`,\n        ...style\n      },\n      colspan: colspanAttr.value\n    })])]) : h(tag, {\n      class: 'q-virtual-scroll__padding',\n      key: 'after',\n      ref: afterRef,\n      style: {\n        [paddingSize]: `${virtualScrollPaddingAfter.value}px`,\n        ...style\n      }\n    })];\n  }\n  function emitScroll(index) {\n    if (prevToIndex !== index) {\n      props.onVirtualScroll !== void 0 && emit('virtualScroll', {\n        index,\n        from: virtualScrollSliceRange.value.from,\n        to: virtualScrollSliceRange.value.to - 1,\n        direction: index < prevToIndex ? 'decrease' : 'increase',\n        ref: proxy\n      });\n      prevToIndex = index;\n    }\n  }\n  setVirtualScrollSize();\n  const onVirtualScrollEvt = debounce(localOnVirtualScrollEvt, $q.platform.is.ios === true ? 120 : 35);\n  onBeforeMount(() => {\n    setVirtualScrollSize();\n  });\n  let shouldActivate = false;\n  onDeactivated(() => {\n    shouldActivate = true;\n  });\n  onActivated(() => {\n    if (shouldActivate !== true) {\n      return;\n    }\n    const scrollEl = getVirtualScrollTarget();\n    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n      setScroll(scrollEl, prevScrollStart, props.virtualScrollHorizontal, $q.lang.rtl);\n    } else {\n      scrollTo(prevToIndex);\n    }\n  });\n  __QUASAR_SSR__ || onBeforeUnmount(() => {\n    onVirtualScrollEvt.cancel();\n  });\n\n  // expose public methods\n  Object.assign(proxy, {\n    scrollTo,\n    reset,\n    refresh\n  });\n  return {\n    virtualScrollSliceRange,\n    virtualScrollSliceSizeComputed,\n    setVirtualScrollSize,\n    onVirtualScrollEvt,\n    localResetVirtualScroll,\n    padVirtualScroll,\n    scrollTo,\n    reset,\n    refresh\n  };\n}","map":{"version":3,"names":["h","ref","computed","watch","onActivated","onDeactivated","onBeforeMount","onBeforeUnmount","nextTick","getCurrentInstance","debounce","noop","rtlHasScrollBug","aggBucketSize","scrollToEdges","filterProto","Array","prototype","filter","setOverflowAnchor","__QUASAR_SSR__","window","getComputedStyle","document","body","overflowAnchor","contentEl","index","_qOverflowAnimationFrame","cancelAnimationFrame","requestAnimationFrame","children","call","el","dataset","qVsAnchor","forEach","sumFn","acc","getScrollDetails","parent","child","beforeRef","afterRef","horizontal","rtl","stickyStart","stickyEnd","parentCalc","scrollingElement","documentElement","propElSize","details","scrollStart","scrollViewSize","scrollMaxSize","offsetStart","offsetEnd","pageXOffset","scrollX","scrollLeft","clientWidth","scrollWidth","pageYOffset","scrollY","scrollTop","clientHeight","scrollHeight","previousElementSibling","classList","contains","nextElementSibling","parentRect","getBoundingClientRect","childRect","left","width","top","height","setScroll","scroll","scrollTo","offsetWidth","sumSize","sizeAgg","size","from","to","lastTo","length","fromAgg","Math","floor","toAgg","total","slice","reduce","commonVirtScrollProps","virtualScrollSliceSize","type","Number","String","default","virtualScrollSliceRatioBefore","virtualScrollSliceRatioAfter","virtualScrollItemSize","virtualScrollStickySizeStart","virtualScrollStickySizeEnd","tableColspan","commonVirtPropsList","Object","keys","useVirtualScrollProps","virtualScrollHorizontal","Boolean","onVirtualScroll","Function","useVirtualScroll","virtualScrollLength","getVirtualScrollTarget","getVirtualScrollEl","virtualScrollItemSizeComputed","vm","props","emit","proxy","$q","prevScrollStart","prevToIndex","localScrollViewSize","virtualScrollSizesAgg","virtualScrollSizes","virtualScrollPaddingBefore","virtualScrollPaddingAfter","virtualScrollSliceSizeComputed","contentRef","virtualScrollSliceRange","colspanAttr","needsReset","value","needsSliceRecalc","setVirtualScrollSize","reset","localResetVirtualScroll","refresh","toIndex","edge","scrollEl","nodeType","scrollDetails","lang","setVirtualScrollSliceRange","min","max","parseInt","indexOf","localOnVirtualScrollEvt","listLastIndex","listEndOffset","updateVirtualScrollSizes","scrollMaxStart","ceil","listOffset","offset","j","align","alignForce","alignEnd","replace","alignRange","rangeChanged","emitScroll","activeElement","addEventListener","onBlurRefocusFn","setTimeout","removeEventListener","sizeBefore","tempTo","sizeAfter","posStart","posEnd","scrollPosition","sizeDiff","round","childrenLength","sizeFn","offsetHeight","diff","i","focus","fullReset","defaultSize","isArray","oldVirtualScrollSizesLength","jMax","iMax","push","onVirtualScrollEvt","parseFloat","multiplier","view","baseSize","start","center","end","padVirtualScroll","tag","content","paddingSize","style","class","key","colspan","tabindex","flat","direction","platform","is","ios","shouldActivate","cancel","assign"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/components/virtual-scroll/use-virtual-scroll.js"],"sourcesContent":["import { h, ref, computed, watch, onActivated, onDeactivated, onBeforeMount, onBeforeUnmount, nextTick, getCurrentInstance } from 'vue'\n\nimport debounce from '../../utils/debounce.js'\nimport { noop } from '../../utils/event.js'\nimport { rtlHasScrollBug } from '../../utils/private/rtl.js'\n\nconst aggBucketSize = 1000\n\nconst scrollToEdges = [\n  'start',\n  'center',\n  'end',\n  'start-force',\n  'center-force',\n  'end-force'\n]\n\nconst filterProto = Array.prototype.filter\n\nconst setOverflowAnchor = __QUASAR_SSR__ || window.getComputedStyle(document.body).overflowAnchor === void 0\n  ? noop\n  : function (contentEl, index) {\n    if (contentEl === null) {\n      return\n    }\n\n    if (contentEl._qOverflowAnimationFrame !== void 0) {\n      cancelAnimationFrame(contentEl._qOverflowAnimationFrame)\n    }\n\n    contentEl._qOverflowAnimationFrame = requestAnimationFrame(() => {\n      if (contentEl === null) {\n        return\n      }\n\n      contentEl._qOverflowAnimationFrame = void 0\n      const children = contentEl.children || []\n\n      filterProto\n        .call(children, el => el.dataset && el.dataset.qVsAnchor !== void 0)\n        .forEach(el => {\n          delete el.dataset.qVsAnchor\n        })\n\n      const el = children[ index ]\n\n      if (el && el.dataset) {\n        el.dataset.qVsAnchor = ''\n      }\n    })\n  }\n\nfunction sumFn (acc, h) {\n  return acc + h\n}\n\nfunction getScrollDetails (\n  parent,\n  child,\n  beforeRef,\n  afterRef,\n  horizontal,\n  rtl,\n  stickyStart,\n  stickyEnd\n) {\n  const\n    parentCalc = parent === window ? document.scrollingElement || document.documentElement : parent,\n    propElSize = horizontal === true ? 'offsetWidth' : 'offsetHeight',\n    details = {\n      scrollStart: 0,\n      scrollViewSize: -stickyStart - stickyEnd,\n      scrollMaxSize: 0,\n      offsetStart: -stickyStart,\n      offsetEnd: -stickyEnd\n    }\n\n  if (horizontal === true) {\n    if (parent === window) {\n      details.scrollStart = window.pageXOffset || window.scrollX || document.body.scrollLeft || 0\n      details.scrollViewSize += document.documentElement.clientWidth\n    }\n    else {\n      details.scrollStart = parentCalc.scrollLeft\n      details.scrollViewSize += parentCalc.clientWidth\n    }\n    details.scrollMaxSize = parentCalc.scrollWidth\n\n    if (rtl === true) {\n      details.scrollStart = (rtlHasScrollBug === true ? details.scrollMaxSize - details.scrollViewSize : 0) - details.scrollStart\n    }\n  }\n  else {\n    if (parent === window) {\n      details.scrollStart = window.pageYOffset || window.scrollY || document.body.scrollTop || 0\n      details.scrollViewSize += document.documentElement.clientHeight\n    }\n    else {\n      details.scrollStart = parentCalc.scrollTop\n      details.scrollViewSize += parentCalc.clientHeight\n    }\n    details.scrollMaxSize = parentCalc.scrollHeight\n  }\n\n  if (beforeRef !== null) {\n    for (let el = beforeRef.previousElementSibling; el !== null; el = el.previousElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetStart += el[ propElSize ]\n      }\n    }\n  }\n\n  if (afterRef !== null) {\n    for (let el = afterRef.nextElementSibling; el !== null; el = el.nextElementSibling) {\n      if (el.classList.contains('q-virtual-scroll--skip') === false) {\n        details.offsetEnd += el[ propElSize ]\n      }\n    }\n  }\n\n  if (child !== parent) {\n    const\n      parentRect = parentCalc.getBoundingClientRect(),\n      childRect = child.getBoundingClientRect()\n\n    if (horizontal === true) {\n      details.offsetStart += childRect.left - parentRect.left\n      details.offsetEnd -= childRect.width\n    }\n    else {\n      details.offsetStart += childRect.top - parentRect.top\n      details.offsetEnd -= childRect.height\n    }\n\n    if (parent !== window) {\n      details.offsetStart += details.scrollStart\n    }\n    details.offsetEnd += details.scrollMaxSize - details.offsetStart\n  }\n\n  return details\n}\n\nfunction setScroll (parent, scroll, horizontal, rtl) {\n  if (scroll === 'end') {\n    scroll = (parent === window ? document.body : parent)[\n      horizontal === true ? 'scrollWidth' : 'scrollHeight'\n    ]\n  }\n\n  if (parent === window) {\n    if (horizontal === true) {\n      if (rtl === true) {\n        scroll = (rtlHasScrollBug === true ? document.body.scrollWidth - document.documentElement.clientWidth : 0) - scroll\n      }\n      window.scrollTo(scroll, window.pageYOffset || window.scrollY || document.body.scrollTop || 0)\n    }\n    else {\n      window.scrollTo(window.pageXOffset || window.scrollX || document.body.scrollLeft || 0, scroll)\n    }\n  }\n  else if (horizontal === true) {\n    if (rtl === true) {\n      scroll = (rtlHasScrollBug === true ? parent.scrollWidth - parent.offsetWidth : 0) - scroll\n    }\n    parent.scrollLeft = scroll\n  }\n  else {\n    parent.scrollTop = scroll\n  }\n}\n\nfunction sumSize (sizeAgg, size, from, to) {\n  if (from >= to) { return 0 }\n\n  const\n    lastTo = size.length,\n    fromAgg = Math.floor(from / aggBucketSize),\n    toAgg = Math.floor((to - 1) / aggBucketSize) + 1\n\n  let total = sizeAgg.slice(fromAgg, toAgg).reduce(sumFn, 0)\n\n  if (from % aggBucketSize !== 0) {\n    total -= size.slice(fromAgg * aggBucketSize, from).reduce(sumFn, 0)\n  }\n  if (to % aggBucketSize !== 0 && to !== lastTo) {\n    total -= size.slice(to, toAgg * aggBucketSize).reduce(sumFn, 0)\n  }\n\n  return total\n}\n\nconst commonVirtScrollProps = {\n  virtualScrollSliceSize: {\n    type: [ Number, String ],\n    default: null\n  },\n\n  virtualScrollSliceRatioBefore: {\n    type: [ Number, String ],\n    default: 1\n  },\n\n  virtualScrollSliceRatioAfter: {\n    type: [ Number, String ],\n    default: 1\n  },\n\n  virtualScrollItemSize: {\n    type: [ Number, String ],\n    default: 24\n  },\n\n  virtualScrollStickySizeStart: {\n    type: [ Number, String ],\n    default: 0\n  },\n\n  virtualScrollStickySizeEnd: {\n    type: [ Number, String ],\n    default: 0\n  },\n\n  tableColspan: [ Number, String ]\n}\n\nexport const commonVirtPropsList = Object.keys(commonVirtScrollProps)\n\nexport const useVirtualScrollProps = {\n  virtualScrollHorizontal: Boolean,\n  onVirtualScroll: Function,\n  ...commonVirtScrollProps\n}\n\nexport function useVirtualScroll ({\n  virtualScrollLength, getVirtualScrollTarget, getVirtualScrollEl,\n  virtualScrollItemSizeComputed // optional\n}) {\n  const vm = getCurrentInstance()\n\n  const { props, emit, proxy } = vm\n  const { $q } = proxy\n\n  let prevScrollStart, prevToIndex, localScrollViewSize, virtualScrollSizesAgg = [], virtualScrollSizes\n\n  const virtualScrollPaddingBefore = ref(0)\n  const virtualScrollPaddingAfter = ref(0)\n  const virtualScrollSliceSizeComputed = ref({})\n\n  const beforeRef = ref(null)\n  const afterRef = ref(null)\n  const contentRef = ref(null)\n\n  const virtualScrollSliceRange = ref({ from: 0, to: 0 })\n\n  const colspanAttr = computed(() => (props.tableColspan !== void 0 ? props.tableColspan : 100))\n\n  if (virtualScrollItemSizeComputed === void 0) {\n    virtualScrollItemSizeComputed = computed(() => props.virtualScrollItemSize)\n  }\n\n  const needsReset = computed(() => virtualScrollItemSizeComputed.value + ';' + props.virtualScrollHorizontal)\n\n  const needsSliceRecalc = computed(() =>\n    needsReset.value + ';' + props.virtualScrollSliceRatioBefore + ';' + props.virtualScrollSliceRatioAfter\n  )\n\n  watch(needsSliceRecalc, () => { setVirtualScrollSize() })\n  watch(needsReset, reset)\n\n  function reset () {\n    localResetVirtualScroll(prevToIndex, true)\n  }\n\n  function refresh (toIndex) {\n    localResetVirtualScroll(toIndex === void 0 ? prevToIndex : toIndex)\n  }\n\n  function scrollTo (toIndex, edge) {\n    const scrollEl = getVirtualScrollTarget()\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return\n    }\n\n    const scrollDetails = getScrollDetails(\n      scrollEl,\n      getVirtualScrollEl(),\n      beforeRef.value,\n      afterRef.value,\n      props.virtualScrollHorizontal,\n      $q.lang.rtl,\n      props.virtualScrollStickySizeStart,\n      props.virtualScrollStickySizeEnd\n    )\n\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize)\n\n    setVirtualScrollSliceRange(\n      scrollEl,\n      scrollDetails,\n      Math.min(virtualScrollLength.value - 1, Math.max(0, parseInt(toIndex, 10) || 0)),\n      0,\n      scrollToEdges.indexOf(edge) > -1 ? edge : (prevToIndex > -1 && toIndex > prevToIndex ? 'end' : 'start')\n    )\n  }\n\n  function localOnVirtualScrollEvt () {\n    const scrollEl = getVirtualScrollTarget()\n\n    if (scrollEl === void 0 || scrollEl === null || scrollEl.nodeType === 8) {\n      return\n    }\n\n    const\n      scrollDetails = getScrollDetails(\n        scrollEl,\n        getVirtualScrollEl(),\n        beforeRef.value,\n        afterRef.value,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl,\n        props.virtualScrollStickySizeStart,\n        props.virtualScrollStickySizeEnd\n      ),\n      listLastIndex = virtualScrollLength.value - 1,\n      listEndOffset = scrollDetails.scrollMaxSize - scrollDetails.offsetStart - scrollDetails.offsetEnd - virtualScrollPaddingAfter.value\n\n    if (prevScrollStart === scrollDetails.scrollStart) {\n      return\n    }\n\n    if (scrollDetails.scrollMaxSize <= 0) {\n      setVirtualScrollSliceRange(scrollEl, scrollDetails, 0, 0)\n      return\n    }\n\n    localScrollViewSize !== scrollDetails.scrollViewSize && setVirtualScrollSize(scrollDetails.scrollViewSize)\n\n    updateVirtualScrollSizes(virtualScrollSliceRange.value.from)\n\n    const scrollMaxStart = Math.floor(scrollDetails.scrollMaxSize\n      - Math.max(scrollDetails.scrollViewSize, scrollDetails.offsetEnd)\n      - Math.min(virtualScrollSizes[ listLastIndex ], scrollDetails.scrollViewSize / 2))\n\n    if (scrollMaxStart > 0 && Math.ceil(scrollDetails.scrollStart) >= scrollMaxStart) {\n      setVirtualScrollSliceRange(\n        scrollEl,\n        scrollDetails,\n        listLastIndex,\n        scrollDetails.scrollMaxSize - scrollDetails.offsetEnd - virtualScrollSizesAgg.reduce(sumFn, 0)\n      )\n\n      return\n    }\n\n    let\n      toIndex = 0,\n      listOffset = scrollDetails.scrollStart - scrollDetails.offsetStart,\n      offset = listOffset\n\n    if (listOffset <= listEndOffset && listOffset + scrollDetails.scrollViewSize >= virtualScrollPaddingBefore.value) {\n      listOffset -= virtualScrollPaddingBefore.value\n      toIndex = virtualScrollSliceRange.value.from\n      offset = listOffset\n    }\n    else {\n      for (let j = 0; listOffset >= virtualScrollSizesAgg[ j ] && toIndex < listLastIndex; j++) {\n        listOffset -= virtualScrollSizesAgg[ j ]\n        toIndex += aggBucketSize\n      }\n    }\n\n    while (listOffset > 0 && toIndex < listLastIndex) {\n      listOffset -= virtualScrollSizes[ toIndex ]\n      if (listOffset > -scrollDetails.scrollViewSize) {\n        toIndex++\n        offset = listOffset\n      }\n      else {\n        offset = virtualScrollSizes[ toIndex ] + listOffset\n      }\n    }\n\n    setVirtualScrollSliceRange(\n      scrollEl,\n      scrollDetails,\n      toIndex,\n      offset\n    )\n  }\n\n  function setVirtualScrollSliceRange (scrollEl, scrollDetails, toIndex, offset, align) {\n    const alignForce = typeof align === 'string' && align.indexOf('-force') > -1\n    const alignEnd = alignForce === true ? align.replace('-force', '') : align\n    const alignRange = alignEnd !== void 0 ? alignEnd : 'start'\n\n    let\n      from = Math.max(0, toIndex - virtualScrollSliceSizeComputed.value[ alignRange ]),\n      to = from + virtualScrollSliceSizeComputed.value.total\n\n    if (to > virtualScrollLength.value) {\n      to = virtualScrollLength.value\n      from = Math.max(0, to - virtualScrollSliceSizeComputed.value.total)\n    }\n\n    prevScrollStart = scrollDetails.scrollStart\n\n    const rangeChanged = from !== virtualScrollSliceRange.value.from || to !== virtualScrollSliceRange.value.to\n\n    if (rangeChanged === false && alignEnd === void 0) {\n      emitScroll(toIndex)\n      return\n    }\n\n    const { activeElement } = document\n    const contentEl = contentRef.value\n    if (\n      rangeChanged === true\n      && contentEl !== null\n      && contentEl !== activeElement\n      && contentEl.contains(activeElement) === true\n    ) {\n      contentEl.addEventListener('focusout', onBlurRefocusFn)\n\n      setTimeout(() => {\n        contentEl !== null && contentEl.removeEventListener('focusout', onBlurRefocusFn)\n      })\n    }\n\n    setOverflowAnchor(contentEl, toIndex - from)\n\n    const sizeBefore = alignEnd !== void 0 ? virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0) : 0\n\n    if (rangeChanged === true) {\n      // vue key matching algorithm works only if\n      // the array of VNodes changes on only one of the ends\n      // so we first change one end and then the other\n\n      const tempTo = to >= virtualScrollSliceRange.value.from && from <= virtualScrollSliceRange.value.to\n        ? virtualScrollSliceRange.value.to\n        : to\n\n      virtualScrollSliceRange.value = { from, to: tempTo }\n      virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, from)\n      virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value)\n\n      requestAnimationFrame(() => {\n        if (virtualScrollSliceRange.value.to !== to && prevScrollStart === scrollDetails.scrollStart) {\n          virtualScrollSliceRange.value = { from: virtualScrollSliceRange.value.from, to }\n          virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, to, virtualScrollLength.value)\n        }\n      })\n    }\n\n    requestAnimationFrame(() => {\n      // if the scroll was changed give up\n      // (another call to setVirtualScrollSliceRange before animation frame)\n      if (prevScrollStart !== scrollDetails.scrollStart) {\n        return\n      }\n\n      if (rangeChanged === true) {\n        updateVirtualScrollSizes(from)\n      }\n\n      const\n        sizeAfter = virtualScrollSizes.slice(from, toIndex).reduce(sumFn, 0),\n        posStart = sizeAfter + scrollDetails.offsetStart + virtualScrollPaddingBefore.value,\n        posEnd = posStart + virtualScrollSizes[ toIndex ]\n\n      let scrollPosition = posStart + offset\n\n      if (alignEnd !== void 0) {\n        const sizeDiff = sizeAfter - sizeBefore\n        const scrollStart = scrollDetails.scrollStart + sizeDiff\n\n        scrollPosition = alignForce !== true && scrollStart < posStart && posEnd < scrollStart + scrollDetails.scrollViewSize\n          ? scrollStart\n          : (\n              alignEnd === 'end'\n                ? posEnd - scrollDetails.scrollViewSize\n                : posStart - (alignEnd === 'start' ? 0 : Math.round((scrollDetails.scrollViewSize - virtualScrollSizes[ toIndex ]) / 2))\n            )\n      }\n\n      prevScrollStart = scrollPosition\n\n      setScroll(\n        scrollEl,\n        scrollPosition,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl\n      )\n\n      emitScroll(toIndex)\n    })\n  }\n\n  function updateVirtualScrollSizes (from) {\n    const contentEl = contentRef.value\n\n    if (contentEl) {\n      const\n        children = filterProto.call(\n          contentEl.children,\n          el => el.classList && el.classList.contains('q-virtual-scroll--skip') === false\n        ),\n        childrenLength = children.length,\n        sizeFn = props.virtualScrollHorizontal === true\n          ? el => el.getBoundingClientRect().width\n          : el => el.offsetHeight\n\n      let\n        index = from,\n        size, diff\n\n      for (let i = 0; i < childrenLength;) {\n        size = sizeFn(children[ i ])\n        i++\n\n        while (i < childrenLength && children[ i ].classList.contains('q-virtual-scroll--with-prev') === true) {\n          size += sizeFn(children[ i ])\n          i++\n        }\n\n        diff = size - virtualScrollSizes[ index ]\n\n        if (diff !== 0) {\n          virtualScrollSizes[ index ] += diff\n          virtualScrollSizesAgg[ Math.floor(index / aggBucketSize) ] += diff\n        }\n\n        index++\n      }\n    }\n  }\n\n  function onBlurRefocusFn () {\n    contentRef.value !== null && contentRef.value !== void 0 && contentRef.value.focus()\n  }\n\n  function localResetVirtualScroll (toIndex, fullReset) {\n    const defaultSize = 1 * virtualScrollItemSizeComputed.value\n\n    if (fullReset === true || Array.isArray(virtualScrollSizes) === false) {\n      virtualScrollSizes = []\n    }\n\n    const oldVirtualScrollSizesLength = virtualScrollSizes.length\n\n    virtualScrollSizes.length = virtualScrollLength.value\n\n    for (let i = virtualScrollLength.value - 1; i >= oldVirtualScrollSizesLength; i--) {\n      virtualScrollSizes[ i ] = defaultSize\n    }\n\n    const jMax = Math.floor((virtualScrollLength.value - 1) / aggBucketSize)\n    virtualScrollSizesAgg = []\n    for (let j = 0; j <= jMax; j++) {\n      let size = 0\n      const iMax = Math.min((j + 1) * aggBucketSize, virtualScrollLength.value)\n      for (let i = j * aggBucketSize; i < iMax; i++) {\n        size += virtualScrollSizes[ i ]\n      }\n      virtualScrollSizesAgg.push(size)\n    }\n\n    prevToIndex = -1\n    prevScrollStart = void 0\n\n    virtualScrollPaddingBefore.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, 0, virtualScrollSliceRange.value.from)\n    virtualScrollPaddingAfter.value = sumSize(virtualScrollSizesAgg, virtualScrollSizes, virtualScrollSliceRange.value.to, virtualScrollLength.value)\n\n    if (toIndex >= 0) {\n      updateVirtualScrollSizes(virtualScrollSliceRange.value.from)\n      nextTick(() => { scrollTo(toIndex) })\n    }\n    else {\n      onVirtualScrollEvt()\n    }\n  }\n\n  function setVirtualScrollSize (scrollViewSize) {\n    if (scrollViewSize === void 0 && typeof window !== 'undefined') {\n      const scrollEl = getVirtualScrollTarget()\n\n      if (scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n        scrollViewSize = getScrollDetails(\n          scrollEl,\n          getVirtualScrollEl(),\n          beforeRef.value,\n          afterRef.value,\n          props.virtualScrollHorizontal,\n          $q.lang.rtl,\n          props.virtualScrollStickySizeStart,\n          props.virtualScrollStickySizeEnd\n        ).scrollViewSize\n      }\n    }\n\n    localScrollViewSize = scrollViewSize\n\n    const virtualScrollSliceRatioBefore = parseFloat(props.virtualScrollSliceRatioBefore) || 0\n    const virtualScrollSliceRatioAfter = parseFloat(props.virtualScrollSliceRatioAfter) || 0\n    const multiplier = 1 + virtualScrollSliceRatioBefore + virtualScrollSliceRatioAfter\n    const view = scrollViewSize === void 0 || scrollViewSize <= 0\n      ? 1\n      : Math.ceil(scrollViewSize / virtualScrollItemSizeComputed.value)\n\n    const baseSize = Math.max(\n      1,\n      view,\n      Math.ceil((props.virtualScrollSliceSize > 0 ? props.virtualScrollSliceSize : 10) / multiplier)\n    )\n\n    virtualScrollSliceSizeComputed.value = {\n      total: Math.ceil(baseSize * multiplier),\n      start: Math.ceil(baseSize * virtualScrollSliceRatioBefore),\n      center: Math.ceil(baseSize * (0.5 + virtualScrollSliceRatioBefore)),\n      end: Math.ceil(baseSize * (1 + virtualScrollSliceRatioBefore)),\n      view\n    }\n  }\n\n  function padVirtualScroll (tag, content) {\n    const paddingSize = props.virtualScrollHorizontal === true ? 'width' : 'height'\n    const style = {\n      [ '--q-virtual-scroll-item-' + paddingSize ]: virtualScrollItemSizeComputed.value + 'px'\n    }\n\n    return [\n      tag === 'tbody'\n        ? h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'before',\n          ref: beforeRef\n        }, [\n          h('tr', [\n            h('td', {\n              style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style },\n              colspan: colspanAttr.value\n            })\n          ])\n        ])\n        : h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'before',\n          ref: beforeRef,\n          style: { [ paddingSize ]: `${ virtualScrollPaddingBefore.value }px`, ...style }\n        }),\n\n      h(tag, {\n        class: 'q-virtual-scroll__content',\n        key: 'content',\n        ref: contentRef,\n        tabindex: -1\n      }, content.flat()),\n\n      tag === 'tbody'\n        ? h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'after',\n          ref: afterRef\n        }, [\n          h('tr', [\n            h('td', {\n              style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style },\n              colspan: colspanAttr.value\n            })\n          ])\n        ])\n        : h(tag, {\n          class: 'q-virtual-scroll__padding',\n          key: 'after',\n          ref: afterRef,\n          style: { [ paddingSize ]: `${ virtualScrollPaddingAfter.value }px`, ...style }\n        })\n    ]\n  }\n\n  function emitScroll (index) {\n    if (prevToIndex !== index) {\n      props.onVirtualScroll !== void 0 && emit('virtualScroll', {\n        index,\n        from: virtualScrollSliceRange.value.from,\n        to: virtualScrollSliceRange.value.to - 1,\n        direction: index < prevToIndex ? 'decrease' : 'increase',\n        ref: proxy\n      })\n\n      prevToIndex = index\n    }\n  }\n\n  setVirtualScrollSize()\n  const onVirtualScrollEvt = debounce(\n    localOnVirtualScrollEvt,\n    $q.platform.is.ios === true ? 120 : 35\n  )\n\n  onBeforeMount(() => {\n    setVirtualScrollSize()\n  })\n\n  let shouldActivate = false\n\n  onDeactivated(() => {\n    shouldActivate = true\n  })\n\n  onActivated(() => {\n    if (shouldActivate !== true) { return }\n\n    const scrollEl = getVirtualScrollTarget()\n\n    if (prevScrollStart !== void 0 && scrollEl !== void 0 && scrollEl !== null && scrollEl.nodeType !== 8) {\n      setScroll(\n        scrollEl,\n        prevScrollStart,\n        props.virtualScrollHorizontal,\n        $q.lang.rtl\n      )\n    }\n    else {\n      scrollTo(prevToIndex)\n    }\n  })\n\n  __QUASAR_SSR__ || onBeforeUnmount(() => {\n    onVirtualScrollEvt.cancel()\n  })\n\n  // expose public methods\n  Object.assign(proxy, { scrollTo, reset, refresh })\n\n  return {\n    virtualScrollSliceRange,\n    virtualScrollSliceSizeComputed,\n\n    setVirtualScrollSize,\n    onVirtualScrollEvt,\n    localResetVirtualScroll,\n    padVirtualScroll,\n\n    scrollTo,\n    reset,\n    refresh\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}