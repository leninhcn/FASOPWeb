{"ast":null,"code":"import { client } from '../plugins/Platform.js';\nimport { createDirective } from '../utils/private/create.js';\nimport { getModifierDirections, shouldStart } from '../utils/private/touch.js';\nimport { addEvt, cleanEvt, position, leftClick, prevent, stop, stopAndPrevent, preventDraggable, noop } from '../utils/event.js';\nimport { clearSelection } from '../utils/private/selection.js';\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js';\nfunction getChanges(evt, ctx, isFinal) {\n  const pos = position(evt);\n  let dir,\n    distX = pos.left - ctx.event.x,\n    distY = pos.top - ctx.event.y,\n    absX = Math.abs(distX),\n    absY = Math.abs(distY);\n  const direction = ctx.direction;\n  if (direction.horizontal === true && direction.vertical !== true) {\n    dir = distX < 0 ? 'left' : 'right';\n  } else if (direction.horizontal !== true && direction.vertical === true) {\n    dir = distY < 0 ? 'up' : 'down';\n  } else if (direction.up === true && distY < 0) {\n    dir = 'up';\n    if (absX > absY) {\n      if (direction.left === true && distX < 0) {\n        dir = 'left';\n      } else if (direction.right === true && distX > 0) {\n        dir = 'right';\n      }\n    }\n  } else if (direction.down === true && distY > 0) {\n    dir = 'down';\n    if (absX > absY) {\n      if (direction.left === true && distX < 0) {\n        dir = 'left';\n      } else if (direction.right === true && distX > 0) {\n        dir = 'right';\n      }\n    }\n  } else if (direction.left === true && distX < 0) {\n    dir = 'left';\n    if (absX < absY) {\n      if (direction.up === true && distY < 0) {\n        dir = 'up';\n      } else if (direction.down === true && distY > 0) {\n        dir = 'down';\n      }\n    }\n  } else if (direction.right === true && distX > 0) {\n    dir = 'right';\n    if (absX < absY) {\n      if (direction.up === true && distY < 0) {\n        dir = 'up';\n      } else if (direction.down === true && distY > 0) {\n        dir = 'down';\n      }\n    }\n  }\n  let synthetic = false;\n  if (dir === void 0 && isFinal === false) {\n    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {\n      return {};\n    }\n    dir = ctx.event.lastDir;\n    synthetic = true;\n    if (dir === 'left' || dir === 'right') {\n      pos.left -= distX;\n      absX = 0;\n      distX = 0;\n    } else {\n      pos.top -= distY;\n      absY = 0;\n      distY = 0;\n    }\n  }\n  return {\n    synthetic,\n    payload: {\n      evt,\n      touch: ctx.event.mouse !== true,\n      mouse: ctx.event.mouse === true,\n      position: pos,\n      direction: dir,\n      isFirst: ctx.event.isFirst,\n      isFinal: isFinal === true,\n      duration: Date.now() - ctx.event.time,\n      distance: {\n        x: absX,\n        y: absY\n      },\n      offset: {\n        x: distX,\n        y: distY\n      },\n      delta: {\n        x: pos.left - ctx.event.lastX,\n        y: pos.top - ctx.event.lastY\n      }\n    }\n  };\n}\nlet uid = 0;\nexport default createDirective(__QUASAR_SSR_SERVER__ ? {\n  name: 'touch-pan',\n  getSSRProps\n} : {\n  name: 'touch-pan',\n  beforeMount(el, {\n    value,\n    modifiers\n  }) {\n    // early return, we don't need to do anything\n    if (modifiers.mouse !== true && client.has.touch !== true) {\n      return;\n    }\n    function handleEvent(evt, mouseEvent) {\n      if (modifiers.mouse === true && mouseEvent === true) {\n        stopAndPrevent(evt);\n      } else {\n        modifiers.stop === true && stop(evt);\n        modifiers.prevent === true && prevent(evt);\n      }\n    }\n    const ctx = {\n      uid: 'qvtp_' + uid++,\n      handler: value,\n      modifiers,\n      direction: getModifierDirections(modifiers),\n      noop,\n      mouseStart(evt) {\n        if (shouldStart(evt, ctx) && leftClick(evt)) {\n          addEvt(ctx, 'temp', [[document, 'mousemove', 'move', 'notPassiveCapture'], [document, 'mouseup', 'end', 'passiveCapture']]);\n          ctx.start(evt, true);\n        }\n      },\n      touchStart(evt) {\n        if (shouldStart(evt, ctx)) {\n          const target = evt.target;\n          addEvt(ctx, 'temp', [[target, 'touchmove', 'move', 'notPassiveCapture'], [target, 'touchcancel', 'end', 'passiveCapture'], [target, 'touchend', 'end', 'passiveCapture']]);\n          ctx.start(evt);\n        }\n      },\n      start(evt, mouseEvent) {\n        client.is.firefox === true && preventDraggable(el, true);\n        ctx.lastEvt = evt;\n\n        /*\n        * Stop propagation so possible upper v-touch-pan don't catch this as well;\n        * If we're not the target (based on modifiers), we'll re-emit the event later\n        */\n        if (mouseEvent === true || modifiers.stop === true) {\n          /*\n          * are we directly switching to detected state?\n          * clone event only otherwise\n          */\n          if (ctx.direction.all !== true\n          // account for UMD too where modifiers will be lowercased to work\n          && (mouseEvent !== true || ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true)) {\n            const clone = evt.type.indexOf('mouse') > -1 ? new MouseEvent(evt.type, evt) : new TouchEvent(evt.type, evt);\n            evt.defaultPrevented === true && prevent(clone);\n            evt.cancelBubble === true && stop(clone);\n            Object.assign(clone, {\n              qKeyEvent: evt.qKeyEvent,\n              qClickOutside: evt.qClickOutside,\n              qAnchorHandled: evt.qAnchorHandled,\n              qClonedBy: evt.qClonedBy === void 0 ? [ctx.uid] : evt.qClonedBy.concat(ctx.uid)\n            });\n            ctx.initialEvent = {\n              target: evt.target,\n              event: clone\n            };\n          }\n          stop(evt);\n        }\n        const {\n          left,\n          top\n        } = position(evt);\n        ctx.event = {\n          x: left,\n          y: top,\n          time: Date.now(),\n          mouse: mouseEvent === true,\n          detected: false,\n          isFirst: true,\n          isFinal: false,\n          lastX: left,\n          lastY: top\n        };\n      },\n      move(evt) {\n        if (ctx.event === void 0) {\n          return;\n        }\n        const pos = position(evt),\n          distX = pos.left - ctx.event.x,\n          distY = pos.top - ctx.event.y;\n\n        // prevent buggy browser behavior (like Blink-based engine ones on Windows)\n        // where the mousemove event occurs even if there's no movement after mousedown\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=161464\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=721341\n        // https://github.com/quasarframework/quasar/issues/10721\n        if (distX === 0 && distY === 0) {\n          return;\n        }\n        ctx.lastEvt = evt;\n        const isMouseEvt = ctx.event.mouse === true;\n        const start = () => {\n          handleEvent(evt, isMouseEvt);\n          let cursor;\n          if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {\n            cursor = document.documentElement.style.cursor || '';\n            document.documentElement.style.cursor = 'grabbing';\n          }\n          isMouseEvt === true && document.body.classList.add('no-pointer-events--children');\n          document.body.classList.add('non-selectable');\n          clearSelection();\n          ctx.styleCleanup = withDelayedFn => {\n            ctx.styleCleanup = void 0;\n            if (cursor !== void 0) {\n              document.documentElement.style.cursor = cursor;\n            }\n            document.body.classList.remove('non-selectable');\n            if (isMouseEvt === true) {\n              const remove = () => {\n                document.body.classList.remove('no-pointer-events--children');\n              };\n              if (withDelayedFn !== void 0) {\n                setTimeout(() => {\n                  remove();\n                  withDelayedFn();\n                }, 50);\n              } else {\n                remove();\n              }\n            } else if (withDelayedFn !== void 0) {\n              withDelayedFn();\n            }\n          };\n        };\n        if (ctx.event.detected === true) {\n          ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse);\n          const {\n            payload,\n            synthetic\n          } = getChanges(evt, ctx, false);\n          if (payload !== void 0) {\n            if (ctx.handler(payload) === false) {\n              ctx.end(evt);\n            } else {\n              if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {\n                start();\n              }\n              ctx.event.lastX = payload.position.left;\n              ctx.event.lastY = payload.position.top;\n              ctx.event.lastDir = synthetic === true ? void 0 : payload.direction;\n              ctx.event.isFirst = false;\n            }\n          }\n          return;\n        }\n        if (ctx.direction.all === true\n        // account for UMD too where modifiers will be lowercased to work\n        || isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true)) {\n          start();\n          ctx.event.detected = true;\n          ctx.move(evt);\n          return;\n        }\n        const absX = Math.abs(distX),\n          absY = Math.abs(distY);\n        if (absX !== absY) {\n          if (ctx.direction.horizontal === true && absX > absY || ctx.direction.vertical === true && absX < absY || ctx.direction.up === true && absX < absY && distY < 0 || ctx.direction.down === true && absX < absY && distY > 0 || ctx.direction.left === true && absX > absY && distX < 0 || ctx.direction.right === true && absX > absY && distX > 0) {\n            ctx.event.detected = true;\n            ctx.move(evt);\n          } else {\n            ctx.end(evt, true);\n          }\n        }\n      },\n      end(evt, abort) {\n        if (ctx.event === void 0) {\n          return;\n        }\n        cleanEvt(ctx, 'temp');\n        client.is.firefox === true && preventDraggable(el, false);\n        if (abort === true) {\n          ctx.styleCleanup !== void 0 && ctx.styleCleanup();\n          if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {\n            ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event);\n          }\n        } else if (ctx.event.detected === true) {\n          ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload);\n          const {\n            payload\n          } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true);\n          const fn = () => {\n            ctx.handler(payload);\n          };\n          if (ctx.styleCleanup !== void 0) {\n            ctx.styleCleanup(fn);\n          } else {\n            fn();\n          }\n        }\n        ctx.event = void 0;\n        ctx.initialEvent = void 0;\n        ctx.lastEvt = void 0;\n      }\n    };\n    el.__qtouchpan = ctx;\n    if (modifiers.mouse === true) {\n      // account for UMD too where modifiers will be lowercased to work\n      const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? 'Capture' : '';\n      addEvt(ctx, 'main', [[el, 'mousedown', 'mouseStart', `passive${capture}`]]);\n    }\n    client.has.touch === true && addEvt(ctx, 'main', [[el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}`], [el, 'touchmove', 'noop', 'notPassiveCapture'] // cannot be passive (ex: iOS scroll)\n    ]);\n  },\n\n  updated(el, bindings) {\n    const ctx = el.__qtouchpan;\n    if (ctx !== void 0) {\n      if (bindings.oldValue !== bindings.value) {\n        typeof value !== 'function' && ctx.end();\n        ctx.handler = bindings.value;\n      }\n      ctx.direction = getModifierDirections(bindings.modifiers);\n    }\n  },\n  beforeUnmount(el) {\n    const ctx = el.__qtouchpan;\n    if (ctx !== void 0) {\n      // emit the end event when the directive is destroyed while active\n      // this is only needed in TouchPan because the rest of the touch directives do not emit an end event\n      // the condition is also checked in the start of function but we avoid the call\n      ctx.event !== void 0 && ctx.end();\n      cleanEvt(ctx, 'main');\n      cleanEvt(ctx, 'temp');\n      client.is.firefox === true && preventDraggable(el, false);\n      ctx.styleCleanup !== void 0 && ctx.styleCleanup();\n      delete el.__qtouchpan;\n    }\n  }\n});","map":{"version":3,"names":["client","createDirective","getModifierDirections","shouldStart","addEvt","cleanEvt","position","leftClick","prevent","stop","stopAndPrevent","preventDraggable","noop","clearSelection","getSSRProps","getChanges","evt","ctx","isFinal","pos","dir","distX","left","event","x","distY","top","y","absX","Math","abs","absY","direction","horizontal","vertical","up","right","down","synthetic","isFirst","lastDir","payload","touch","mouse","duration","Date","now","time","distance","offset","delta","lastX","lastY","uid","__QUASAR_SSR_SERVER__","name","beforeMount","el","value","modifiers","has","handleEvent","mouseEvent","handler","mouseStart","document","start","touchStart","target","is","firefox","lastEvt","all","mouseAllDir","mousealldir","clone","type","indexOf","MouseEvent","TouchEvent","defaultPrevented","cancelBubble","Object","assign","qKeyEvent","qClickOutside","qAnchorHandled","qClonedBy","concat","initialEvent","detected","move","isMouseEvt","cursor","preserveCursor","preservecursor","documentElement","style","body","classList","add","styleCleanup","withDelayedFn","remove","setTimeout","end","abort","dispatchEvent","fn","__qtouchpan","capture","mouseCapture","mousecapture","updated","bindings","oldValue","beforeUnmount"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/directives/TouchPan.js"],"sourcesContent":["import { client } from '../plugins/Platform.js'\n\nimport { createDirective } from '../utils/private/create.js'\nimport { getModifierDirections, shouldStart } from '../utils/private/touch.js'\nimport { addEvt, cleanEvt, position, leftClick, prevent, stop, stopAndPrevent, preventDraggable, noop } from '../utils/event.js'\nimport { clearSelection } from '../utils/private/selection.js'\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js'\n\nfunction getChanges (evt, ctx, isFinal) {\n  const pos = position(evt)\n  let\n    dir,\n    distX = pos.left - ctx.event.x,\n    distY = pos.top - ctx.event.y,\n    absX = Math.abs(distX),\n    absY = Math.abs(distY)\n\n  const direction = ctx.direction\n\n  if (direction.horizontal === true && direction.vertical !== true) {\n    dir = distX < 0 ? 'left' : 'right'\n  }\n  else if (direction.horizontal !== true && direction.vertical === true) {\n    dir = distY < 0 ? 'up' : 'down'\n  }\n  else if (direction.up === true && distY < 0) {\n    dir = 'up'\n    if (absX > absY) {\n      if (direction.left === true && distX < 0) {\n        dir = 'left'\n      }\n      else if (direction.right === true && distX > 0) {\n        dir = 'right'\n      }\n    }\n  }\n  else if (direction.down === true && distY > 0) {\n    dir = 'down'\n    if (absX > absY) {\n      if (direction.left === true && distX < 0) {\n        dir = 'left'\n      }\n      else if (direction.right === true && distX > 0) {\n        dir = 'right'\n      }\n    }\n  }\n  else if (direction.left === true && distX < 0) {\n    dir = 'left'\n    if (absX < absY) {\n      if (direction.up === true && distY < 0) {\n        dir = 'up'\n      }\n      else if (direction.down === true && distY > 0) {\n        dir = 'down'\n      }\n    }\n  }\n  else if (direction.right === true && distX > 0) {\n    dir = 'right'\n    if (absX < absY) {\n      if (direction.up === true && distY < 0) {\n        dir = 'up'\n      }\n      else if (direction.down === true && distY > 0) {\n        dir = 'down'\n      }\n    }\n  }\n\n  let synthetic = false\n\n  if (dir === void 0 && isFinal === false) {\n    if (ctx.event.isFirst === true || ctx.event.lastDir === void 0) {\n      return {}\n    }\n\n    dir = ctx.event.lastDir\n    synthetic = true\n\n    if (dir === 'left' || dir === 'right') {\n      pos.left -= distX\n      absX = 0\n      distX = 0\n    }\n    else {\n      pos.top -= distY\n      absY = 0\n      distY = 0\n    }\n  }\n\n  return {\n    synthetic,\n    payload: {\n      evt,\n      touch: ctx.event.mouse !== true,\n      mouse: ctx.event.mouse === true,\n      position: pos,\n      direction: dir,\n      isFirst: ctx.event.isFirst,\n      isFinal: isFinal === true,\n      duration: Date.now() - ctx.event.time,\n      distance: {\n        x: absX,\n        y: absY\n      },\n      offset: {\n        x: distX,\n        y: distY\n      },\n      delta: {\n        x: pos.left - ctx.event.lastX,\n        y: pos.top - ctx.event.lastY\n      }\n    }\n  }\n}\n\nlet uid = 0\n\nexport default createDirective(__QUASAR_SSR_SERVER__\n  ? { name: 'touch-pan', getSSRProps }\n  : {\n      name: 'touch-pan',\n\n      beforeMount (el, { value, modifiers }) {\n        // early return, we don't need to do anything\n        if (modifiers.mouse !== true && client.has.touch !== true) {\n          return\n        }\n\n        function handleEvent (evt, mouseEvent) {\n          if (modifiers.mouse === true && mouseEvent === true) {\n            stopAndPrevent(evt)\n          }\n          else {\n            modifiers.stop === true && stop(evt)\n            modifiers.prevent === true && prevent(evt)\n          }\n        }\n\n        const ctx = {\n          uid: 'qvtp_' + (uid++),\n          handler: value,\n          modifiers,\n          direction: getModifierDirections(modifiers),\n\n          noop,\n\n          mouseStart (evt) {\n            if (shouldStart(evt, ctx) && leftClick(evt)) {\n              addEvt(ctx, 'temp', [\n                [ document, 'mousemove', 'move', 'notPassiveCapture' ],\n                [ document, 'mouseup', 'end', 'passiveCapture' ]\n              ])\n\n              ctx.start(evt, true)\n            }\n          },\n\n          touchStart (evt) {\n            if (shouldStart(evt, ctx)) {\n              const target = evt.target\n\n              addEvt(ctx, 'temp', [\n                [ target, 'touchmove', 'move', 'notPassiveCapture' ],\n                [ target, 'touchcancel', 'end', 'passiveCapture' ],\n                [ target, 'touchend', 'end', 'passiveCapture' ]\n              ])\n\n              ctx.start(evt)\n            }\n          },\n\n          start (evt, mouseEvent) {\n            client.is.firefox === true && preventDraggable(el, true)\n            ctx.lastEvt = evt\n\n            /*\n            * Stop propagation so possible upper v-touch-pan don't catch this as well;\n            * If we're not the target (based on modifiers), we'll re-emit the event later\n            */\n            if (mouseEvent === true || modifiers.stop === true) {\n              /*\n              * are we directly switching to detected state?\n              * clone event only otherwise\n              */\n              if (\n                ctx.direction.all !== true\n                // account for UMD too where modifiers will be lowercased to work\n                && (mouseEvent !== true || (ctx.modifiers.mouseAllDir !== true && ctx.modifiers.mousealldir !== true))\n              ) {\n                const clone = evt.type.indexOf('mouse') > -1\n                  ? new MouseEvent(evt.type, evt)\n                  : new TouchEvent(evt.type, evt)\n\n                evt.defaultPrevented === true && prevent(clone)\n                evt.cancelBubble === true && stop(clone)\n\n                Object.assign(clone, {\n                  qKeyEvent: evt.qKeyEvent,\n                  qClickOutside: evt.qClickOutside,\n                  qAnchorHandled: evt.qAnchorHandled,\n                  qClonedBy: evt.qClonedBy === void 0\n                    ? [ ctx.uid ]\n                    : evt.qClonedBy.concat(ctx.uid)\n                })\n\n                ctx.initialEvent = {\n                  target: evt.target,\n                  event: clone\n                }\n              }\n\n              stop(evt)\n            }\n\n            const { left, top } = position(evt)\n\n            ctx.event = {\n              x: left,\n              y: top,\n              time: Date.now(),\n              mouse: mouseEvent === true,\n              detected: false,\n              isFirst: true,\n              isFinal: false,\n              lastX: left,\n              lastY: top\n            }\n          },\n\n          move (evt) {\n            if (ctx.event === void 0) {\n              return\n            }\n\n            const\n              pos = position(evt),\n              distX = pos.left - ctx.event.x,\n              distY = pos.top - ctx.event.y\n\n            // prevent buggy browser behavior (like Blink-based engine ones on Windows)\n            // where the mousemove event occurs even if there's no movement after mousedown\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=161464\n            // https://bugs.chromium.org/p/chromium/issues/detail?id=721341\n            // https://github.com/quasarframework/quasar/issues/10721\n            if (distX === 0 && distY === 0) {\n              return\n            }\n\n            ctx.lastEvt = evt\n\n            const isMouseEvt = ctx.event.mouse === true\n            const start = () => {\n              handleEvent(evt, isMouseEvt)\n\n              let cursor\n              if (modifiers.preserveCursor !== true && modifiers.preservecursor !== true) {\n                cursor = document.documentElement.style.cursor || ''\n                document.documentElement.style.cursor = 'grabbing'\n              }\n\n              isMouseEvt === true && document.body.classList.add('no-pointer-events--children')\n              document.body.classList.add('non-selectable')\n              clearSelection()\n\n              ctx.styleCleanup = withDelayedFn => {\n                ctx.styleCleanup = void 0\n\n                if (cursor !== void 0) {\n                  document.documentElement.style.cursor = cursor\n                }\n\n                document.body.classList.remove('non-selectable')\n\n                if (isMouseEvt === true) {\n                  const remove = () => {\n                    document.body.classList.remove('no-pointer-events--children')\n                  }\n\n                  if (withDelayedFn !== void 0) {\n                    setTimeout(() => {\n                      remove()\n                      withDelayedFn()\n                    }, 50)\n                  }\n                  else { remove() }\n                }\n                else if (withDelayedFn !== void 0) {\n                  withDelayedFn()\n                }\n              }\n            }\n\n            if (ctx.event.detected === true) {\n              ctx.event.isFirst !== true && handleEvent(evt, ctx.event.mouse)\n\n              const { payload, synthetic } = getChanges(evt, ctx, false)\n\n              if (payload !== void 0) {\n                if (ctx.handler(payload) === false) {\n                  ctx.end(evt)\n                }\n                else {\n                  if (ctx.styleCleanup === void 0 && ctx.event.isFirst === true) {\n                    start()\n                  }\n\n                  ctx.event.lastX = payload.position.left\n                  ctx.event.lastY = payload.position.top\n                  ctx.event.lastDir = synthetic === true ? void 0 : payload.direction\n                  ctx.event.isFirst = false\n                }\n              }\n\n              return\n            }\n\n            if (\n              ctx.direction.all === true\n              // account for UMD too where modifiers will be lowercased to work\n              || (isMouseEvt === true && (ctx.modifiers.mouseAllDir === true || ctx.modifiers.mousealldir === true))\n            ) {\n              start()\n              ctx.event.detected = true\n              ctx.move(evt)\n              return\n            }\n\n            const\n              absX = Math.abs(distX),\n              absY = Math.abs(distY)\n\n            if (absX !== absY) {\n              if (\n                (ctx.direction.horizontal === true && absX > absY)\n                || (ctx.direction.vertical === true && absX < absY)\n                || (ctx.direction.up === true && absX < absY && distY < 0)\n                || (ctx.direction.down === true && absX < absY && distY > 0)\n                || (ctx.direction.left === true && absX > absY && distX < 0)\n                || (ctx.direction.right === true && absX > absY && distX > 0)\n              ) {\n                ctx.event.detected = true\n                ctx.move(evt)\n              }\n              else {\n                ctx.end(evt, true)\n              }\n            }\n          },\n\n          end (evt, abort) {\n            if (ctx.event === void 0) {\n              return\n            }\n\n            cleanEvt(ctx, 'temp')\n            client.is.firefox === true && preventDraggable(el, false)\n\n            if (abort === true) {\n              ctx.styleCleanup !== void 0 && ctx.styleCleanup()\n\n              if (ctx.event.detected !== true && ctx.initialEvent !== void 0) {\n                ctx.initialEvent.target.dispatchEvent(ctx.initialEvent.event)\n              }\n            }\n            else if (ctx.event.detected === true) {\n              ctx.event.isFirst === true && ctx.handler(getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx).payload)\n\n              const { payload } = getChanges(evt === void 0 ? ctx.lastEvt : evt, ctx, true)\n              const fn = () => { ctx.handler(payload) }\n\n              if (ctx.styleCleanup !== void 0) {\n                ctx.styleCleanup(fn)\n              }\n              else {\n                fn()\n              }\n            }\n\n            ctx.event = void 0\n            ctx.initialEvent = void 0\n            ctx.lastEvt = void 0\n          }\n        }\n\n        el.__qtouchpan = ctx\n\n        if (modifiers.mouse === true) {\n          // account for UMD too where modifiers will be lowercased to work\n          const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true\n            ? 'Capture'\n            : ''\n\n          addEvt(ctx, 'main', [\n            [ el, 'mousedown', 'mouseStart', `passive${ capture }` ]\n          ])\n        }\n\n        client.has.touch === true && addEvt(ctx, 'main', [\n          [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],\n          [ el, 'touchmove', 'noop', 'notPassiveCapture' ] // cannot be passive (ex: iOS scroll)\n        ])\n      },\n\n      updated (el, bindings) {\n        const ctx = el.__qtouchpan\n\n        if (ctx !== void 0) {\n          if (bindings.oldValue !== bindings.value) {\n            typeof value !== 'function' && ctx.end()\n            ctx.handler = bindings.value\n          }\n\n          ctx.direction = getModifierDirections(bindings.modifiers)\n        }\n      },\n\n      beforeUnmount (el) {\n        const ctx = el.__qtouchpan\n\n        if (ctx !== void 0) {\n          // emit the end event when the directive is destroyed while active\n          // this is only needed in TouchPan because the rest of the touch directives do not emit an end event\n          // the condition is also checked in the start of function but we avoid the call\n          ctx.event !== void 0 && ctx.end()\n\n          cleanEvt(ctx, 'main')\n          cleanEvt(ctx, 'temp')\n\n          client.is.firefox === true && preventDraggable(el, false)\n          ctx.styleCleanup !== void 0 && ctx.styleCleanup()\n\n          delete el.__qtouchpan\n        }\n      }\n    }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}