{"ast":null,"code":"import { client } from '../plugins/Platform.js';\nimport { createDirective } from '../utils/private/create.js';\nimport { getModifierDirections, shouldStart } from '../utils/private/touch.js';\nimport { addEvt, cleanEvt, position, leftClick, stopAndPrevent, preventDraggable, noop } from '../utils/event.js';\nimport { clearSelection } from '../utils/private/selection.js';\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js';\nfunction parseArg(arg) {\n  // delta (min velocity -- dist / time)\n  // mobile min distance on first move\n  // desktop min distance until deciding if it's a swipe or not\n  const data = [0.06, 6, 50];\n  if (typeof arg === 'string' && arg.length) {\n    arg.split(':').forEach((val, index) => {\n      const v = parseFloat(val);\n      v && (data[index] = v);\n    });\n  }\n  return data;\n}\nexport default createDirective(__QUASAR_SSR_SERVER__ ? {\n  name: 'touch-swipe',\n  getSSRProps\n} : {\n  name: 'touch-swipe',\n  beforeMount(el, {\n    value,\n    arg,\n    modifiers\n  }) {\n    // early return, we don't need to do anything\n    if (modifiers.mouse !== true && client.has.touch !== true) {\n      return;\n    }\n    const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : '';\n    const ctx = {\n      handler: value,\n      sensitivity: parseArg(arg),\n      direction: getModifierDirections(modifiers),\n      noop,\n      mouseStart(evt) {\n        if (shouldStart(evt, ctx) && leftClick(evt)) {\n          addEvt(ctx, 'temp', [[document, 'mousemove', 'move', `notPassive${mouseCapture}`], [document, 'mouseup', 'end', 'notPassiveCapture']]);\n          ctx.start(evt, true);\n        }\n      },\n      touchStart(evt) {\n        if (shouldStart(evt, ctx)) {\n          const target = evt.target;\n          addEvt(ctx, 'temp', [[target, 'touchmove', 'move', 'notPassiveCapture'], [target, 'touchcancel', 'end', 'notPassiveCapture'], [target, 'touchend', 'end', 'notPassiveCapture']]);\n          ctx.start(evt);\n        }\n      },\n      start(evt, mouseEvent) {\n        client.is.firefox === true && preventDraggable(el, true);\n        const pos = position(evt);\n        ctx.event = {\n          x: pos.left,\n          y: pos.top,\n          time: Date.now(),\n          mouse: mouseEvent === true,\n          dir: false\n        };\n      },\n      move(evt) {\n        if (ctx.event === void 0) {\n          return;\n        }\n        if (ctx.event.dir !== false) {\n          stopAndPrevent(evt);\n          return;\n        }\n        const time = Date.now() - ctx.event.time;\n        if (time === 0) {\n          return;\n        }\n        const pos = position(evt),\n          distX = pos.left - ctx.event.x,\n          absX = Math.abs(distX),\n          distY = pos.top - ctx.event.y,\n          absY = Math.abs(distY);\n        if (ctx.event.mouse !== true) {\n          if (absX < ctx.sensitivity[1] && absY < ctx.sensitivity[1]) {\n            ctx.end(evt);\n            return;\n          }\n        }\n        // is user trying to select text?\n        // if so, then something should be reported here\n        // (previous selection, if any, was discarded when swipe started)\n        else if (window.getSelection().toString() !== '') {\n          ctx.end(evt);\n          return;\n        } else if (absX < ctx.sensitivity[2] && absY < ctx.sensitivity[2]) {\n          return;\n        }\n        const velX = absX / time,\n          velY = absY / time;\n        if (ctx.direction.vertical === true && absX < absY && absX < 100 && velY > ctx.sensitivity[0]) {\n          ctx.event.dir = distY < 0 ? 'up' : 'down';\n        }\n        if (ctx.direction.horizontal === true && absX > absY && absY < 100 && velX > ctx.sensitivity[0]) {\n          ctx.event.dir = distX < 0 ? 'left' : 'right';\n        }\n        if (ctx.direction.up === true && absX < absY && distY < 0 && absX < 100 && velY > ctx.sensitivity[0]) {\n          ctx.event.dir = 'up';\n        }\n        if (ctx.direction.down === true && absX < absY && distY > 0 && absX < 100 && velY > ctx.sensitivity[0]) {\n          ctx.event.dir = 'down';\n        }\n        if (ctx.direction.left === true && absX > absY && distX < 0 && absY < 100 && velX > ctx.sensitivity[0]) {\n          ctx.event.dir = 'left';\n        }\n        if (ctx.direction.right === true && absX > absY && distX > 0 && absY < 100 && velX > ctx.sensitivity[0]) {\n          ctx.event.dir = 'right';\n        }\n        if (ctx.event.dir !== false) {\n          stopAndPrevent(evt);\n          if (ctx.event.mouse === true) {\n            document.body.classList.add('no-pointer-events--children');\n            document.body.classList.add('non-selectable');\n            clearSelection();\n            ctx.styleCleanup = withDelay => {\n              ctx.styleCleanup = void 0;\n              document.body.classList.remove('non-selectable');\n              const remove = () => {\n                document.body.classList.remove('no-pointer-events--children');\n              };\n              if (withDelay === true) {\n                setTimeout(remove, 50);\n              } else {\n                remove();\n              }\n            };\n          }\n          ctx.handler({\n            evt,\n            touch: ctx.event.mouse !== true,\n            mouse: ctx.event.mouse,\n            direction: ctx.event.dir,\n            duration: time,\n            distance: {\n              x: absX,\n              y: absY\n            }\n          });\n        } else {\n          ctx.end(evt);\n        }\n      },\n      end(evt) {\n        if (ctx.event === void 0) {\n          return;\n        }\n        cleanEvt(ctx, 'temp');\n        client.is.firefox === true && preventDraggable(el, false);\n        ctx.styleCleanup !== void 0 && ctx.styleCleanup(true);\n        evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt);\n        ctx.event = void 0;\n      }\n    };\n    el.__qtouchswipe = ctx;\n    if (modifiers.mouse === true) {\n      // account for UMD too where modifiers will be lowercased to work\n      const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true ? 'Capture' : '';\n      addEvt(ctx, 'main', [[el, 'mousedown', 'mouseStart', `passive${capture}`]]);\n    }\n    client.has.touch === true && addEvt(ctx, 'main', [[el, 'touchstart', 'touchStart', `passive${modifiers.capture === true ? 'Capture' : ''}`], [el, 'touchmove', 'noop', 'notPassiveCapture'] // cannot be passive (ex: iOS scroll)\n    ]);\n  },\n\n  updated(el, bindings) {\n    const ctx = el.__qtouchswipe;\n    if (ctx !== void 0) {\n      if (bindings.oldValue !== bindings.value) {\n        typeof bindings.value !== 'function' && ctx.end();\n        ctx.handler = bindings.value;\n      }\n      ctx.direction = getModifierDirections(bindings.modifiers);\n    }\n  },\n  beforeUnmount(el) {\n    const ctx = el.__qtouchswipe;\n    if (ctx !== void 0) {\n      cleanEvt(ctx, 'main');\n      cleanEvt(ctx, 'temp');\n      client.is.firefox === true && preventDraggable(el, false);\n      ctx.styleCleanup !== void 0 && ctx.styleCleanup();\n      delete el.__qtouchswipe;\n    }\n  }\n});","map":{"version":3,"names":["client","createDirective","getModifierDirections","shouldStart","addEvt","cleanEvt","position","leftClick","stopAndPrevent","preventDraggable","noop","clearSelection","getSSRProps","parseArg","arg","data","length","split","forEach","val","index","v","parseFloat","__QUASAR_SSR_SERVER__","name","beforeMount","el","value","modifiers","mouse","has","touch","mouseCapture","ctx","handler","sensitivity","direction","mouseStart","evt","document","start","touchStart","target","mouseEvent","is","firefox","pos","event","x","left","y","top","time","Date","now","dir","move","distX","absX","Math","abs","distY","absY","end","window","getSelection","toString","velX","velY","vertical","horizontal","up","down","right","body","classList","add","styleCleanup","withDelay","remove","setTimeout","duration","distance","__qtouchswipe","capture","mousecapture","updated","bindings","oldValue","beforeUnmount"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/directives/TouchSwipe.js"],"sourcesContent":["import { client } from '../plugins/Platform.js'\n\nimport { createDirective } from '../utils/private/create.js'\nimport { getModifierDirections, shouldStart } from '../utils/private/touch.js'\nimport { addEvt, cleanEvt, position, leftClick, stopAndPrevent, preventDraggable, noop } from '../utils/event.js'\nimport { clearSelection } from '../utils/private/selection.js'\nimport getSSRProps from '../utils/private/noop-ssr-directive-transform.js'\n\nfunction parseArg (arg) {\n  // delta (min velocity -- dist / time)\n  // mobile min distance on first move\n  // desktop min distance until deciding if it's a swipe or not\n  const data = [ 0.06, 6, 50 ]\n\n  if (typeof arg === 'string' && arg.length) {\n    arg.split(':').forEach((val, index) => {\n      const v = parseFloat(val)\n      v && (data[ index ] = v)\n    })\n  }\n\n  return data\n}\n\nexport default createDirective(__QUASAR_SSR_SERVER__\n  ? { name: 'touch-swipe', getSSRProps }\n  : {\n      name: 'touch-swipe',\n\n      beforeMount (el, { value, arg, modifiers }) {\n        // early return, we don't need to do anything\n        if (modifiers.mouse !== true && client.has.touch !== true) {\n          return\n        }\n\n        const mouseCapture = modifiers.mouseCapture === true ? 'Capture' : ''\n\n        const ctx = {\n          handler: value,\n          sensitivity: parseArg(arg),\n          direction: getModifierDirections(modifiers),\n\n          noop,\n\n          mouseStart (evt) {\n            if (shouldStart(evt, ctx) && leftClick(evt)) {\n              addEvt(ctx, 'temp', [\n                [ document, 'mousemove', 'move', `notPassive${ mouseCapture }` ],\n                [ document, 'mouseup', 'end', 'notPassiveCapture' ]\n              ])\n              ctx.start(evt, true)\n            }\n          },\n\n          touchStart (evt) {\n            if (shouldStart(evt, ctx)) {\n              const target = evt.target\n              addEvt(ctx, 'temp', [\n                [ target, 'touchmove', 'move', 'notPassiveCapture' ],\n                [ target, 'touchcancel', 'end', 'notPassiveCapture' ],\n                [ target, 'touchend', 'end', 'notPassiveCapture' ]\n              ])\n              ctx.start(evt)\n            }\n          },\n\n          start (evt, mouseEvent) {\n            client.is.firefox === true && preventDraggable(el, true)\n\n            const pos = position(evt)\n\n            ctx.event = {\n              x: pos.left,\n              y: pos.top,\n              time: Date.now(),\n              mouse: mouseEvent === true,\n              dir: false\n            }\n          },\n\n          move (evt) {\n            if (ctx.event === void 0) {\n              return\n            }\n\n            if (ctx.event.dir !== false) {\n              stopAndPrevent(evt)\n              return\n            }\n\n            const time = Date.now() - ctx.event.time\n\n            if (time === 0) {\n              return\n            }\n\n            const\n              pos = position(evt),\n              distX = pos.left - ctx.event.x,\n              absX = Math.abs(distX),\n              distY = pos.top - ctx.event.y,\n              absY = Math.abs(distY)\n\n            if (ctx.event.mouse !== true) {\n              if (absX < ctx.sensitivity[ 1 ] && absY < ctx.sensitivity[ 1 ]) {\n                ctx.end(evt)\n                return\n              }\n            }\n            // is user trying to select text?\n            // if so, then something should be reported here\n            // (previous selection, if any, was discarded when swipe started)\n            else if (window.getSelection().toString() !== '') {\n              ctx.end(evt)\n              return\n            }\n            else if (absX < ctx.sensitivity[ 2 ] && absY < ctx.sensitivity[ 2 ]) {\n              return\n            }\n\n            const\n              velX = absX / time,\n              velY = absY / time\n\n            if (\n              ctx.direction.vertical === true\n              && absX < absY\n              && absX < 100\n              && velY > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = distY < 0 ? 'up' : 'down'\n            }\n\n            if (\n              ctx.direction.horizontal === true\n              && absX > absY\n              && absY < 100\n              && velX > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = distX < 0 ? 'left' : 'right'\n            }\n\n            if (\n              ctx.direction.up === true\n              && absX < absY\n              && distY < 0\n              && absX < 100\n              && velY > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = 'up'\n            }\n\n            if (\n              ctx.direction.down === true\n              && absX < absY\n              && distY > 0\n              && absX < 100\n              && velY > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = 'down'\n            }\n\n            if (\n              ctx.direction.left === true\n              && absX > absY\n              && distX < 0\n              && absY < 100\n              && velX > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = 'left'\n            }\n\n            if (\n              ctx.direction.right === true\n              && absX > absY\n              && distX > 0\n              && absY < 100\n              && velX > ctx.sensitivity[ 0 ]\n            ) {\n              ctx.event.dir = 'right'\n            }\n\n            if (ctx.event.dir !== false) {\n              stopAndPrevent(evt)\n\n              if (ctx.event.mouse === true) {\n                document.body.classList.add('no-pointer-events--children')\n                document.body.classList.add('non-selectable')\n                clearSelection()\n\n                ctx.styleCleanup = withDelay => {\n                  ctx.styleCleanup = void 0\n\n                  document.body.classList.remove('non-selectable')\n\n                  const remove = () => {\n                    document.body.classList.remove('no-pointer-events--children')\n                  }\n\n                  if (withDelay === true) { setTimeout(remove, 50) }\n                  else { remove() }\n                }\n              }\n\n              ctx.handler({\n                evt,\n                touch: ctx.event.mouse !== true,\n                mouse: ctx.event.mouse,\n                direction: ctx.event.dir,\n                duration: time,\n                distance: {\n                  x: absX,\n                  y: absY\n                }\n              })\n            }\n            else {\n              ctx.end(evt)\n            }\n          },\n\n          end (evt) {\n            if (ctx.event === void 0) {\n              return\n            }\n\n            cleanEvt(ctx, 'temp')\n            client.is.firefox === true && preventDraggable(el, false)\n            ctx.styleCleanup !== void 0 && ctx.styleCleanup(true)\n            evt !== void 0 && ctx.event.dir !== false && stopAndPrevent(evt)\n\n            ctx.event = void 0\n          }\n        }\n\n        el.__qtouchswipe = ctx\n\n        if (modifiers.mouse === true) {\n          // account for UMD too where modifiers will be lowercased to work\n          const capture = modifiers.mouseCapture === true || modifiers.mousecapture === true\n            ? 'Capture'\n            : ''\n\n          addEvt(ctx, 'main', [\n            [ el, 'mousedown', 'mouseStart', `passive${ capture }` ]\n          ])\n        }\n\n        client.has.touch === true && addEvt(ctx, 'main', [\n          [ el, 'touchstart', 'touchStart', `passive${ modifiers.capture === true ? 'Capture' : '' }` ],\n          [ el, 'touchmove', 'noop', 'notPassiveCapture' ] // cannot be passive (ex: iOS scroll)\n        ])\n      },\n\n      updated (el, bindings) {\n        const ctx = el.__qtouchswipe\n\n        if (ctx !== void 0) {\n          if (bindings.oldValue !== bindings.value) {\n            typeof bindings.value !== 'function' && ctx.end()\n            ctx.handler = bindings.value\n          }\n\n          ctx.direction = getModifierDirections(bindings.modifiers)\n        }\n      },\n\n      beforeUnmount (el) {\n        const ctx = el.__qtouchswipe\n\n        if (ctx !== void 0) {\n          cleanEvt(ctx, 'main')\n          cleanEvt(ctx, 'temp')\n\n          client.is.firefox === true && preventDraggable(el, false)\n          ctx.styleCleanup !== void 0 && ctx.styleCleanup()\n\n          delete el.__qtouchswipe\n        }\n      }\n    }\n)\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}