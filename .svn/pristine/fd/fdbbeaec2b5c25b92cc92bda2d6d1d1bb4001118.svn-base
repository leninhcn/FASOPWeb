{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ref, watch, nextTick } from 'vue';\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js';\n\n// leave NAMED_MASKS at top of file (code referenced from docs)\nconst NAMED_MASKS = {\n  date: '####/##/##',\n  datetime: '####/##/## ##:##',\n  time: '##:##',\n  fulltime: '##:##:##',\n  phone: '(###) ### - ####',\n  card: '#### #### #### ####'\n};\nconst TOKENS = {\n  '#': {\n    pattern: '[\\\\d]',\n    negate: '[^\\\\d]'\n  },\n  S: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]'\n  },\n  N: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]'\n  },\n  A: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  a: {\n    pattern: '[a-zA-Z]',\n    negate: '[^a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  },\n  X: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleUpperCase()\n  },\n  x: {\n    pattern: '[0-9a-zA-Z]',\n    negate: '[^0-9a-zA-Z]',\n    transform: v => v.toLocaleLowerCase()\n  }\n};\nconst KEYS = Object.keys(TOKENS);\nKEYS.forEach(key => {\n  TOKENS[key].regex = new RegExp(TOKENS[key].pattern);\n});\nconst tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\n  escRegex = /[.*+?^${}()|[\\]\\\\]/g;\nconst MARKER = String.fromCharCode(1);\nexport const useMaskProps = {\n  mask: String,\n  reverseFillMask: Boolean,\n  fillMask: [Boolean, String],\n  unmaskedValue: Boolean\n};\nexport default function (props, emit, emitValue, inputRef) {\n  let maskMarked, maskReplaced, computedMask, computedUnmask, pastedTextStart, selectionAnchor;\n  const hasMask = ref(null);\n  const innerValue = ref(getInitialMaskedValue());\n  function getIsTypeText() {\n    return props.autogrow === true || ['textarea', 'text', 'search', 'url', 'tel', 'password'].includes(props.type);\n  }\n  watch(() => props.type + props.autogrow, updateMaskInternals);\n  watch(() => props.mask, v => {\n    if (v !== void 0) {\n      updateMaskValue(innerValue.value, true);\n    } else {\n      const val = unmaskValue(innerValue.value);\n      updateMaskInternals();\n      props.modelValue !== val && emit('update:modelValue', val);\n    }\n  });\n  watch(() => props.fillMask + props.reverseFillMask, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value, true);\n  });\n  watch(() => props.unmaskedValue, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value);\n  });\n  function getInitialMaskedValue() {\n    updateMaskInternals();\n    if (hasMask.value === true) {\n      const masked = maskValue(unmaskValue(props.modelValue));\n      return props.fillMask !== false ? fillWithMask(masked) : masked;\n    }\n    return props.modelValue;\n  }\n  function getPaddedMaskMarked(size) {\n    if (size < maskMarked.length) {\n      return maskMarked.slice(-size);\n    }\n    let pad = '',\n      localMaskMarked = maskMarked;\n    const padPos = localMaskMarked.indexOf(MARKER);\n    if (padPos > -1) {\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\n        pad += MARKER;\n      }\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos);\n    }\n    return localMaskMarked;\n  }\n  function updateMaskInternals() {\n    hasMask.value = props.mask !== void 0 && props.mask.length !== 0 && getIsTypeText();\n    if (hasMask.value === false) {\n      computedUnmask = void 0;\n      maskMarked = '';\n      maskReplaced = '';\n      return;\n    }\n    const localComputedMask = NAMED_MASKS[props.mask] === void 0 ? props.mask : NAMED_MASKS[props.mask],\n      fillChar = typeof props.fillMask === 'string' && props.fillMask.length !== 0 ? props.fillMask.slice(0, 1) : '_',\n      fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\n      unmask = [],\n      extract = [],\n      mask = [];\n    let firstMatch = props.reverseFillMask === true,\n      unmaskChar = '',\n      negateChar = '';\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\n      if (token !== void 0) {\n        const c = TOKENS[token];\n        mask.push(c);\n        negateChar = c.negate;\n        if (firstMatch === true) {\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?');\n          firstMatch = false;\n        }\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?');\n      } else if (esc !== void 0) {\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc);\n        mask.push(esc);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      } else {\n        const c = char1 !== void 0 ? char1 : char2;\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&');\n        mask.push(c);\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?');\n      }\n    });\n    const unmaskMatcher = new RegExp('^' + unmask.join('') + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?' + (unmaskChar === '' ? '' : '[' + unmaskChar + ']*') + '$'),\n      extractLast = extract.length - 1,\n      extractMatcher = extract.map((re, index) => {\n        if (index === 0 && props.reverseFillMask === true) {\n          return new RegExp('^' + fillCharEscaped + '*' + re);\n        } else if (index === extractLast) {\n          return new RegExp('^' + re + '(' + (negateChar === '' ? '.' : negateChar) + '+)?' + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*'));\n        }\n        return new RegExp('^' + re);\n      });\n    computedMask = mask;\n    computedUnmask = val => {\n      const unmaskMatch = unmaskMatcher.exec(props.reverseFillMask === true ? val : val.slice(0, mask.length + 1));\n      if (unmaskMatch !== null) {\n        val = unmaskMatch.slice(1).join('');\n      }\n      const extractMatch = [],\n        extractMatcherLength = extractMatcher.length;\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\n        const m = extractMatcher[i].exec(str);\n        if (m === null) {\n          break;\n        }\n        str = str.slice(m.shift().length);\n        extractMatch.push(...m);\n      }\n      if (extractMatch.length !== 0) {\n        return extractMatch.join('');\n      }\n      return val;\n    };\n    maskMarked = mask.map(v => typeof v === 'string' ? v : MARKER).join('');\n    maskReplaced = maskMarked.split(MARKER).join(fillChar);\n  }\n  function updateMaskValue(rawVal, updateMaskInternalsFlag, inputType) {\n    const inp = inputRef.value,\n      end = inp.selectionEnd,\n      endReverse = inp.value.length - end,\n      unmasked = unmaskValue(rawVal);\n\n    // Update here so unmask uses the original fillChar\n    updateMaskInternalsFlag === true && updateMaskInternals();\n    const preMasked = maskValue(unmasked),\n      masked = props.fillMask !== false ? fillWithMask(preMasked) : preMasked,\n      changed = innerValue.value !== masked;\n\n    // We want to avoid \"flickering\" so we set value immediately\n    inp.value !== masked && (inp.value = masked);\n    changed === true && (innerValue.value = masked);\n    document.activeElement === inp && nextTick(() => {\n      if (masked === maskReplaced) {\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\n        const maxEnd = inp.selectionEnd;\n        let cursor = end - 1;\n        // each non-marker char means we move once to right\n        for (let i = pastedTextStart; i <= cursor && i < maxEnd; i++) {\n          if (maskMarked[i] !== MARKER) {\n            cursor++;\n          }\n        }\n        moveCursor.right(inp, cursor);\n        return;\n      }\n      if (['deleteContentBackward', 'deleteContentForward'].indexOf(inputType) > -1) {\n        const cursor = props.reverseFillMask === true ? end === 0 ? masked.length > preMasked.length ? 1 : 0 : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1 : end;\n        inp.setSelectionRange(cursor, cursor, 'forward');\n        return;\n      }\n      if (props.reverseFillMask === true) {\n        if (changed === true) {\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)));\n          if (cursor === 1 && end === 1) {\n            inp.setSelectionRange(cursor, cursor, 'forward');\n          } else {\n            moveCursor.rightReverse(inp, cursor);\n          }\n        } else {\n          const cursor = masked.length - endReverse;\n          inp.setSelectionRange(cursor, cursor, 'backward');\n        }\n      } else {\n        if (changed === true) {\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1);\n          moveCursor.right(inp, cursor);\n        } else {\n          const cursor = end - 1;\n          moveCursor.right(inp, cursor);\n        }\n      }\n    });\n    const val = props.unmaskedValue === true ? unmaskValue(masked) : masked;\n    String(props.modelValue) !== val && emitValue(val, true);\n  }\n  function moveCursorForPaste(inp, start, end) {\n    const preMasked = maskValue(unmaskValue(inp.value));\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start));\n    pastedTextStart = start;\n    inp.setSelectionRange(start, end, 'forward');\n  }\n  const moveCursor = {\n    left(inp, cursor) {\n      const noMarkBefore = maskMarked.slice(cursor - 1).indexOf(MARKER) === -1;\n      let i = Math.max(0, cursor - 1);\n      for (; i >= 0; i--) {\n        if (maskMarked[i] === MARKER) {\n          cursor = i;\n          noMarkBefore === true && cursor++;\n          break;\n        }\n      }\n      if (i < 0 && maskMarked[cursor] !== void 0 && maskMarked[cursor] !== MARKER) {\n        return moveCursor.right(inp, 0);\n      }\n      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward');\n    },\n    right(inp, cursor) {\n      const limit = inp.value.length;\n      let i = Math.min(limit, cursor + 1);\n      for (; i <= limit; i++) {\n        if (maskMarked[i] === MARKER) {\n          cursor = i;\n          break;\n        } else if (maskMarked[i - 1] === MARKER) {\n          cursor = i;\n        }\n      }\n      if (i > limit && maskMarked[cursor - 1] !== void 0 && maskMarked[cursor - 1] !== MARKER) {\n        return moveCursor.left(inp, limit);\n      }\n      inp.setSelectionRange(cursor, cursor, 'forward');\n    },\n    leftReverse(inp, cursor) {\n      const localMaskMarked = getPaddedMaskMarked(inp.value.length);\n      let i = Math.max(0, cursor - 1);\n      for (; i >= 0; i--) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          cursor = i;\n          break;\n        } else if (localMaskMarked[i] === MARKER) {\n          cursor = i;\n          if (i === 0) {\n            break;\n          }\n        }\n      }\n      if (i < 0 && localMaskMarked[cursor] !== void 0 && localMaskMarked[cursor] !== MARKER) {\n        return moveCursor.rightReverse(inp, 0);\n      }\n      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward');\n    },\n    rightReverse(inp, cursor) {\n      const limit = inp.value.length,\n        localMaskMarked = getPaddedMaskMarked(limit),\n        noMarkBefore = localMaskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1;\n      let i = Math.min(limit, cursor + 1);\n      for (; i <= limit; i++) {\n        if (localMaskMarked[i - 1] === MARKER) {\n          cursor = i;\n          cursor > 0 && noMarkBefore === true && cursor--;\n          break;\n        }\n      }\n      if (i > limit && localMaskMarked[cursor - 1] !== void 0 && localMaskMarked[cursor - 1] !== MARKER) {\n        return moveCursor.leftReverse(inp, limit);\n      }\n      inp.setSelectionRange(cursor, cursor, 'forward');\n    }\n  };\n  function onMaskedClick(e) {\n    emit('click', e);\n    selectionAnchor = void 0;\n  }\n  function onMaskedKeydown(e) {\n    emit('keydown', e);\n    if (shouldIgnoreKey(e) === true) {\n      return;\n    }\n    const inp = inputRef.value,\n      start = inp.selectionStart,\n      end = inp.selectionEnd;\n    if (!e.shiftKey) {\n      selectionAnchor = void 0;\n    }\n    if (e.keyCode === 37 || e.keyCode === 39) {\n      // Left / Right\n      if (e.shiftKey && selectionAnchor === void 0) {\n        selectionAnchor = inp.selectionDirection === 'forward' ? start : end;\n      }\n      const fn = moveCursor[(e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '')];\n      e.preventDefault();\n      fn(inp, selectionAnchor === start ? end : start);\n      if (e.shiftKey) {\n        const cursor = inp.selectionStart;\n        inp.setSelectionRange(Math.min(selectionAnchor, cursor), Math.max(selectionAnchor, cursor), 'forward');\n      }\n    } else if (e.keyCode === 8 // Backspace\n    && props.reverseFillMask !== true && start === end) {\n      moveCursor.left(inp, start);\n      inp.setSelectionRange(inp.selectionStart, end, 'backward');\n    } else if (e.keyCode === 46 // Delete\n    && props.reverseFillMask === true && start === end) {\n      moveCursor.rightReverse(inp, end);\n      inp.setSelectionRange(start, inp.selectionEnd, 'forward');\n    }\n  }\n  function maskValue(val) {\n    if (val === void 0 || val === null || val === '') {\n      return '';\n    }\n    if (props.reverseFillMask === true) {\n      return maskValueReverse(val);\n    }\n    const mask = computedMask;\n    let valIndex = 0,\n      output = '';\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\n      const valChar = val[valIndex],\n        maskDef = mask[maskIndex];\n      if (typeof maskDef === 'string') {\n        output += maskDef;\n        valChar === maskDef && valIndex++;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        output += maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar;\n        valIndex++;\n      } else {\n        return output;\n      }\n    }\n    return output;\n  }\n  function maskValueReverse(val) {\n    const mask = computedMask,\n      firstTokenIndex = maskMarked.indexOf(MARKER);\n    let valIndex = val.length - 1,\n      output = '';\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\n      const maskDef = mask[maskIndex];\n      let valChar = val[valIndex];\n      if (typeof maskDef === 'string') {\n        output = maskDef + output;\n        valChar === maskDef && valIndex--;\n      } else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        do {\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output;\n          valIndex--;\n          valChar = val[valIndex];\n          // eslint-disable-next-line no-unmodified-loop-condition\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar));\n      } else {\n        return output;\n      }\n    }\n    return output;\n  }\n  function unmaskValue(val) {\n    return typeof val !== 'string' || computedUnmask === void 0 ? typeof val === 'number' ? computedUnmask('' + val) : val : computedUnmask(val);\n  }\n  function fillWithMask(val) {\n    if (maskReplaced.length - val.length <= 0) {\n      return val;\n    }\n    return props.reverseFillMask === true && val.length !== 0 ? maskReplaced.slice(0, -val.length) + val : val + maskReplaced.slice(val.length);\n  }\n  return {\n    innerValue,\n    hasMask,\n    moveCursorForPaste,\n    updateMaskValue,\n    onMaskedKeydown,\n    onMaskedClick\n  };\n}","map":{"version":3,"names":["ref","watch","nextTick","shouldIgnoreKey","NAMED_MASKS","date","datetime","time","fulltime","phone","card","TOKENS","pattern","negate","S","N","A","transform","v","toLocaleUpperCase","a","toLocaleLowerCase","X","x","KEYS","Object","keys","forEach","key","regex","RegExp","tokenRegexMask","join","escRegex","MARKER","String","fromCharCode","useMaskProps","mask","reverseFillMask","Boolean","fillMask","unmaskedValue","props","emit","emitValue","inputRef","maskMarked","maskReplaced","computedMask","computedUnmask","pastedTextStart","selectionAnchor","hasMask","innerValue","getInitialMaskedValue","getIsTypeText","autogrow","includes","type","updateMaskInternals","updateMaskValue","value","val","unmaskValue","modelValue","masked","maskValue","fillWithMask","getPaddedMaskMarked","size","length","slice","pad","localMaskMarked","padPos","indexOf","i","localComputedMask","fillChar","fillCharEscaped","replace","unmask","extract","firstMatch","unmaskChar","negateChar","_","char1","esc","token","char2","c","push","unmaskMatcher","extractLast","extractMatcher","map","re","index","unmaskMatch","exec","extractMatch","extractMatcherLength","str","m","shift","split","rawVal","updateMaskInternalsFlag","inputType","inp","end","selectionEnd","endReverse","unmasked","preMasked","changed","document","activeElement","cursor","setSelectionRange","maxEnd","moveCursor","right","Math","max","min","rightReverse","moveCursorForPaste","start","left","noMarkBefore","limit","leftReverse","onMaskedClick","e","onMaskedKeydown","selectionStart","shiftKey","keyCode","selectionDirection","fn","preventDefault","maskValueReverse","valIndex","output","maskIndex","valChar","maskDef","test","firstTokenIndex"],"sources":["D:/LearnVueJS/Vue3/Projects/fa-sop-online/node_modules/quasar/src/components/input/use-mask.js"],"sourcesContent":["import { ref, watch, nextTick } from 'vue'\n\nimport { shouldIgnoreKey } from '../../utils/private/key-composition.js'\n\n// leave NAMED_MASKS at top of file (code referenced from docs)\nconst NAMED_MASKS = {\n  date: '####/##/##',\n  datetime: '####/##/## ##:##',\n  time: '##:##',\n  fulltime: '##:##:##',\n  phone: '(###) ### - ####',\n  card: '#### #### #### ####'\n}\n\nconst TOKENS = {\n  '#': { pattern: '[\\\\d]', negate: '[^\\\\d]' },\n\n  S: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]' },\n  N: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]' },\n\n  A: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleUpperCase() },\n  a: { pattern: '[a-zA-Z]', negate: '[^a-zA-Z]', transform: v => v.toLocaleLowerCase() },\n\n  X: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleUpperCase() },\n  x: { pattern: '[0-9a-zA-Z]', negate: '[^0-9a-zA-Z]', transform: v => v.toLocaleLowerCase() }\n}\n\nconst KEYS = Object.keys(TOKENS)\nKEYS.forEach(key => {\n  TOKENS[ key ].regex = new RegExp(TOKENS[ key ].pattern)\n})\n\nconst\n  tokenRegexMask = new RegExp('\\\\\\\\([^.*+?^${}()|([\\\\]])|([.*+?^${}()|[\\\\]])|([' + KEYS.join('') + '])|(.)', 'g'),\n  escRegex = /[.*+?^${}()|[\\]\\\\]/g\n\nconst MARKER = String.fromCharCode(1)\n\nexport const useMaskProps = {\n  mask: String,\n  reverseFillMask: Boolean,\n  fillMask: [ Boolean, String ],\n  unmaskedValue: Boolean\n}\n\nexport default function (props, emit, emitValue, inputRef) {\n  let maskMarked, maskReplaced, computedMask, computedUnmask, pastedTextStart, selectionAnchor\n\n  const hasMask = ref(null)\n  const innerValue = ref(getInitialMaskedValue())\n\n  function getIsTypeText () {\n    return props.autogrow === true\n      || [ 'textarea', 'text', 'search', 'url', 'tel', 'password' ].includes(props.type)\n  }\n\n  watch(() => props.type + props.autogrow, updateMaskInternals)\n\n  watch(() => props.mask, v => {\n    if (v !== void 0) {\n      updateMaskValue(innerValue.value, true)\n    }\n    else {\n      const val = unmaskValue(innerValue.value)\n      updateMaskInternals()\n      props.modelValue !== val && emit('update:modelValue', val)\n    }\n  })\n\n  watch(() => props.fillMask + props.reverseFillMask, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value, true)\n  })\n\n  watch(() => props.unmaskedValue, () => {\n    hasMask.value === true && updateMaskValue(innerValue.value)\n  })\n\n  function getInitialMaskedValue () {\n    updateMaskInternals()\n\n    if (hasMask.value === true) {\n      const masked = maskValue(unmaskValue(props.modelValue))\n\n      return props.fillMask !== false\n        ? fillWithMask(masked)\n        : masked\n    }\n\n    return props.modelValue\n  }\n\n  function getPaddedMaskMarked (size) {\n    if (size < maskMarked.length) {\n      return maskMarked.slice(-size)\n    }\n\n    let pad = '', localMaskMarked = maskMarked\n    const padPos = localMaskMarked.indexOf(MARKER)\n\n    if (padPos > -1) {\n      for (let i = size - localMaskMarked.length; i > 0; i--) {\n        pad += MARKER\n      }\n\n      localMaskMarked = localMaskMarked.slice(0, padPos) + pad + localMaskMarked.slice(padPos)\n    }\n\n    return localMaskMarked\n  }\n\n  function updateMaskInternals () {\n    hasMask.value = props.mask !== void 0\n      && props.mask.length !== 0\n      && getIsTypeText()\n\n    if (hasMask.value === false) {\n      computedUnmask = void 0\n      maskMarked = ''\n      maskReplaced = ''\n      return\n    }\n\n    const\n      localComputedMask = NAMED_MASKS[ props.mask ] === void 0\n        ? props.mask\n        : NAMED_MASKS[ props.mask ],\n      fillChar = typeof props.fillMask === 'string' && props.fillMask.length !== 0\n        ? props.fillMask.slice(0, 1)\n        : '_',\n      fillCharEscaped = fillChar.replace(escRegex, '\\\\$&'),\n      unmask = [],\n      extract = [],\n      mask = []\n\n    let\n      firstMatch = props.reverseFillMask === true,\n      unmaskChar = '',\n      negateChar = ''\n\n    localComputedMask.replace(tokenRegexMask, (_, char1, esc, token, char2) => {\n      if (token !== void 0) {\n        const c = TOKENS[ token ]\n        mask.push(c)\n        negateChar = c.negate\n        if (firstMatch === true) {\n          extract.push('(?:' + negateChar + '+)?(' + c.pattern + '+)?(?:' + negateChar + '+)?(' + c.pattern + '+)?')\n          firstMatch = false\n        }\n        extract.push('(?:' + negateChar + '+)?(' + c.pattern + ')?')\n      }\n      else if (esc !== void 0) {\n        unmaskChar = '\\\\' + (esc === '\\\\' ? '' : esc)\n        mask.push(esc)\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\n      }\n      else {\n        const c = char1 !== void 0 ? char1 : char2\n        unmaskChar = c === '\\\\' ? '\\\\\\\\\\\\\\\\' : c.replace(escRegex, '\\\\\\\\$&')\n        mask.push(c)\n        unmask.push('([^' + unmaskChar + ']+)?' + unmaskChar + '?')\n      }\n    })\n\n    const\n      unmaskMatcher = new RegExp(\n        '^'\n        + unmask.join('')\n        + '(' + (unmaskChar === '' ? '.' : '[^' + unmaskChar + ']') + '+)?'\n        + (unmaskChar === '' ? '' : '[' + unmaskChar + ']*') + '$'\n      ),\n      extractLast = extract.length - 1,\n      extractMatcher = extract.map((re, index) => {\n        if (index === 0 && props.reverseFillMask === true) {\n          return new RegExp('^' + fillCharEscaped + '*' + re)\n        }\n        else if (index === extractLast) {\n          return new RegExp(\n            '^' + re\n            + '(' + (negateChar === '' ? '.' : negateChar) + '+)?'\n            + (props.reverseFillMask === true ? '$' : fillCharEscaped + '*')\n          )\n        }\n\n        return new RegExp('^' + re)\n      })\n\n    computedMask = mask\n    computedUnmask = val => {\n      const unmaskMatch = unmaskMatcher.exec(props.reverseFillMask === true ? val : val.slice(0, mask.length + 1))\n      if (unmaskMatch !== null) {\n        val = unmaskMatch.slice(1).join('')\n      }\n\n      const\n        extractMatch = [],\n        extractMatcherLength = extractMatcher.length\n\n      for (let i = 0, str = val; i < extractMatcherLength; i++) {\n        const m = extractMatcher[ i ].exec(str)\n\n        if (m === null) {\n          break\n        }\n\n        str = str.slice(m.shift().length)\n        extractMatch.push(...m)\n      }\n      if (extractMatch.length !== 0) {\n        return extractMatch.join('')\n      }\n\n      return val\n    }\n    maskMarked = mask.map(v => (typeof v === 'string' ? v : MARKER)).join('')\n    maskReplaced = maskMarked.split(MARKER).join(fillChar)\n  }\n\n  function updateMaskValue (rawVal, updateMaskInternalsFlag, inputType) {\n    const\n      inp = inputRef.value,\n      end = inp.selectionEnd,\n      endReverse = inp.value.length - end,\n      unmasked = unmaskValue(rawVal)\n\n    // Update here so unmask uses the original fillChar\n    updateMaskInternalsFlag === true && updateMaskInternals()\n\n    const\n      preMasked = maskValue(unmasked),\n      masked = props.fillMask !== false\n        ? fillWithMask(preMasked)\n        : preMasked,\n      changed = innerValue.value !== masked\n\n    // We want to avoid \"flickering\" so we set value immediately\n    inp.value !== masked && (inp.value = masked)\n\n    changed === true && (innerValue.value = masked)\n\n    document.activeElement === inp && nextTick(() => {\n      if (masked === maskReplaced) {\n        const cursor = props.reverseFillMask === true ? maskReplaced.length : 0\n        inp.setSelectionRange(cursor, cursor, 'forward')\n\n        return\n      }\n\n      if (inputType === 'insertFromPaste' && props.reverseFillMask !== true) {\n        const maxEnd = inp.selectionEnd\n        let cursor = end - 1\n        // each non-marker char means we move once to right\n        for (let i = pastedTextStart; i <= cursor && i < maxEnd; i++) {\n          if (maskMarked[ i ] !== MARKER) {\n            cursor++\n          }\n        }\n        moveCursor.right(inp, cursor)\n\n        return\n      }\n\n      if ([ 'deleteContentBackward', 'deleteContentForward' ].indexOf(inputType) > -1) {\n        const cursor = props.reverseFillMask === true\n          ? (\n              end === 0\n                ? (masked.length > preMasked.length ? 1 : 0)\n                : Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse) + 1)) + 1\n            )\n          : end\n\n        inp.setSelectionRange(cursor, cursor, 'forward')\n        return\n      }\n\n      if (props.reverseFillMask === true) {\n        if (changed === true) {\n          const cursor = Math.max(0, masked.length - (masked === maskReplaced ? 0 : Math.min(preMasked.length, endReverse + 1)))\n\n          if (cursor === 1 && end === 1) {\n            inp.setSelectionRange(cursor, cursor, 'forward')\n          }\n          else {\n            moveCursor.rightReverse(inp, cursor)\n          }\n        }\n        else {\n          const cursor = masked.length - endReverse\n          inp.setSelectionRange(cursor, cursor, 'backward')\n        }\n      }\n      else {\n        if (changed === true) {\n          const cursor = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, end) - 1)\n          moveCursor.right(inp, cursor)\n        }\n        else {\n          const cursor = end - 1\n          moveCursor.right(inp, cursor)\n        }\n      }\n    })\n\n    const val = props.unmaskedValue === true\n      ? unmaskValue(masked)\n      : masked\n\n    String(props.modelValue) !== val && emitValue(val, true)\n  }\n\n  function moveCursorForPaste (inp, start, end) {\n    const preMasked = maskValue(unmaskValue(inp.value))\n\n    start = Math.max(0, maskMarked.indexOf(MARKER), Math.min(preMasked.length, start))\n    pastedTextStart = start\n\n    inp.setSelectionRange(start, end, 'forward')\n  }\n\n  const moveCursor = {\n    left (inp, cursor) {\n      const noMarkBefore = maskMarked.slice(cursor - 1).indexOf(MARKER) === -1\n      let i = Math.max(0, cursor - 1)\n\n      for (; i >= 0; i--) {\n        if (maskMarked[ i ] === MARKER) {\n          cursor = i\n          noMarkBefore === true && cursor++\n          break\n        }\n      }\n\n      if (\n        i < 0\n        && maskMarked[ cursor ] !== void 0\n        && maskMarked[ cursor ] !== MARKER\n      ) {\n        return moveCursor.right(inp, 0)\n      }\n\n      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward')\n    },\n\n    right (inp, cursor) {\n      const limit = inp.value.length\n      let i = Math.min(limit, cursor + 1)\n\n      for (; i <= limit; i++) {\n        if (maskMarked[ i ] === MARKER) {\n          cursor = i\n          break\n        }\n        else if (maskMarked[ i - 1 ] === MARKER) {\n          cursor = i\n        }\n      }\n\n      if (\n        i > limit\n        && maskMarked[ cursor - 1 ] !== void 0\n        && maskMarked[ cursor - 1 ] !== MARKER\n      ) {\n        return moveCursor.left(inp, limit)\n      }\n\n      inp.setSelectionRange(cursor, cursor, 'forward')\n    },\n\n    leftReverse (inp, cursor) {\n      const\n        localMaskMarked = getPaddedMaskMarked(inp.value.length)\n      let i = Math.max(0, cursor - 1)\n\n      for (; i >= 0; i--) {\n        if (localMaskMarked[ i - 1 ] === MARKER) {\n          cursor = i\n          break\n        }\n        else if (localMaskMarked[ i ] === MARKER) {\n          cursor = i\n          if (i === 0) {\n            break\n          }\n        }\n      }\n\n      if (\n        i < 0\n        && localMaskMarked[ cursor ] !== void 0\n        && localMaskMarked[ cursor ] !== MARKER\n      ) {\n        return moveCursor.rightReverse(inp, 0)\n      }\n\n      cursor >= 0 && inp.setSelectionRange(cursor, cursor, 'backward')\n    },\n\n    rightReverse (inp, cursor) {\n      const\n        limit = inp.value.length,\n        localMaskMarked = getPaddedMaskMarked(limit),\n        noMarkBefore = localMaskMarked.slice(0, cursor + 1).indexOf(MARKER) === -1\n      let i = Math.min(limit, cursor + 1)\n\n      for (; i <= limit; i++) {\n        if (localMaskMarked[ i - 1 ] === MARKER) {\n          cursor = i\n          cursor > 0 && noMarkBefore === true && cursor--\n          break\n        }\n      }\n\n      if (\n        i > limit\n        && localMaskMarked[ cursor - 1 ] !== void 0\n        && localMaskMarked[ cursor - 1 ] !== MARKER\n      ) {\n        return moveCursor.leftReverse(inp, limit)\n      }\n\n      inp.setSelectionRange(cursor, cursor, 'forward')\n    }\n  }\n\n  function onMaskedClick (e) {\n    emit('click', e)\n\n    selectionAnchor = void 0\n  }\n\n  function onMaskedKeydown (e) {\n    emit('keydown', e)\n\n    if (shouldIgnoreKey(e) === true) {\n      return\n    }\n\n    const\n      inp = inputRef.value,\n      start = inp.selectionStart,\n      end = inp.selectionEnd\n\n    if (!e.shiftKey) {\n      selectionAnchor = void 0\n    }\n\n    if (e.keyCode === 37 || e.keyCode === 39) { // Left / Right\n      if (e.shiftKey && selectionAnchor === void 0) {\n        selectionAnchor = inp.selectionDirection === 'forward' ? start : end\n      }\n\n      const fn = moveCursor[ (e.keyCode === 39 ? 'right' : 'left') + (props.reverseFillMask === true ? 'Reverse' : '') ]\n\n      e.preventDefault()\n      fn(inp, selectionAnchor === start ? end : start)\n\n      if (e.shiftKey) {\n        const cursor = inp.selectionStart\n        inp.setSelectionRange(Math.min(selectionAnchor, cursor), Math.max(selectionAnchor, cursor), 'forward')\n      }\n    }\n    else if (\n      e.keyCode === 8 // Backspace\n      && props.reverseFillMask !== true\n      && start === end\n    ) {\n      moveCursor.left(inp, start)\n      inp.setSelectionRange(inp.selectionStart, end, 'backward')\n    }\n    else if (\n      e.keyCode === 46 // Delete\n      && props.reverseFillMask === true\n      && start === end\n    ) {\n      moveCursor.rightReverse(inp, end)\n      inp.setSelectionRange(start, inp.selectionEnd, 'forward')\n    }\n  }\n\n  function maskValue (val) {\n    if (val === void 0 || val === null || val === '') { return '' }\n\n    if (props.reverseFillMask === true) {\n      return maskValueReverse(val)\n    }\n\n    const mask = computedMask\n\n    let valIndex = 0, output = ''\n\n    for (let maskIndex = 0; maskIndex < mask.length; maskIndex++) {\n      const\n        valChar = val[ valIndex ],\n        maskDef = mask[ maskIndex ]\n\n      if (typeof maskDef === 'string') {\n        output += maskDef\n        valChar === maskDef && valIndex++\n      }\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        output += maskDef.transform !== void 0\n          ? maskDef.transform(valChar)\n          : valChar\n        valIndex++\n      }\n      else {\n        return output\n      }\n    }\n\n    return output\n  }\n\n  function maskValueReverse (val) {\n    const\n      mask = computedMask,\n      firstTokenIndex = maskMarked.indexOf(MARKER)\n\n    let valIndex = val.length - 1, output = ''\n\n    for (let maskIndex = mask.length - 1; maskIndex >= 0 && valIndex > -1; maskIndex--) {\n      const maskDef = mask[ maskIndex ]\n\n      let valChar = val[ valIndex ]\n\n      if (typeof maskDef === 'string') {\n        output = maskDef + output\n        valChar === maskDef && valIndex--\n      }\n      else if (valChar !== void 0 && maskDef.regex.test(valChar)) {\n        do {\n          output = (maskDef.transform !== void 0 ? maskDef.transform(valChar) : valChar) + output\n          valIndex--\n          valChar = val[ valIndex ]\n        // eslint-disable-next-line no-unmodified-loop-condition\n        } while (firstTokenIndex === maskIndex && valChar !== void 0 && maskDef.regex.test(valChar))\n      }\n      else {\n        return output\n      }\n    }\n\n    return output\n  }\n\n  function unmaskValue (val) {\n    return typeof val !== 'string' || computedUnmask === void 0\n      ? (typeof val === 'number' ? computedUnmask('' + val) : val)\n      : computedUnmask(val)\n  }\n\n  function fillWithMask (val) {\n    if (maskReplaced.length - val.length <= 0) {\n      return val\n    }\n\n    return props.reverseFillMask === true && val.length !== 0\n      ? maskReplaced.slice(0, -val.length) + val\n      : val + maskReplaced.slice(val.length)\n  }\n\n  return {\n    innerValue,\n    hasMask,\n    moveCursorForPaste,\n    updateMaskValue,\n    onMaskedKeydown,\n    onMaskedClick\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}